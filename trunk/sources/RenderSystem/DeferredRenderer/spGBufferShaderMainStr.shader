"/*\n"
" * GBuffer pixel shader main file\n"
" * \n"
" * This file is part of the \"SoftPixel Engine\" (Copyright (c) 2008 by Lukas Hermanns)\n"
" * See \"SoftPixelEngine.hpp\" for license information.\n"
" */\n"
"\n"
"#ifndef NORMAL_MAPPING\n"
"\n"
"/* Sample diffuse color */\n"
"DiffuseAndSpecular = tex2D(DiffuseMap, TexCoord);\n"
"\n"
"#   ifdef HAS_SPECULAR_MAP\n"
"/* Sample specular color */\n"
"DiffuseAndSpecular.a = tex2D(SpecularMap, TexCoord).r * SpecularFactor;\n"
"#   endif\n"
"\n"
"NormalAndDepth.xyz = Normal;\n"
"\n"
"#else\n"
"\n"
"#   ifdef PARALLAX_MAPPING\n"
"if (!EnablePOM)\n"
"{\n"
"#   endif\n"
"    \n"
"    /* Sample diffuse color */\n"
"    DiffuseAndSpecular = tex2D(DiffuseMap, TexCoord);\n"
"    \n"
"    /* Perform alpha-test clipping */\n"
"    //clip(Out.DiffuseAndSpecular.a - 0.5);\n"
"    \n"
"    /* Sample normal color */\n"
"    NormalAndDepth.xyz = tex2D(NormalMap, TexCoord).rgb;\n"
"    \n"
"    #ifdef HAS_SPECULAR_MAP\n"
"    /* Sample specular color */\n"
"    DiffuseAndSpecular.a = tex2D(SpecularMap, TexCoord).r * SpecularFactor;\n"
"    #endif\n"
"    \n"
"#   ifdef PARALLAX_MAPPING\n"
"}\n"
"else\n"
"{\n"
"    /* Compute parallax-occlusion displacement */\n"
"    float ParallaxLimit = (length(ViewVertexDirAndDepth.xy) / ViewVertexDirAndDepth.z) * HeightMapScale;\n"
"    \n"
"    float2 Offset       = normalize(-ViewVertexDirAndDepth.xy) * ParallaxLimit;\n"
"    \n"
"    float Interpolation = saturate(ParallaxViewRange / ViewVertexDirAndDepth.w);\n"
"    int NumSamples      = int(mix(float(MinSamplesPOM), float(MaxSamplesPOM), Interpolation));\n"
"    \n"
"    float StepSize      = 1.0 / float(NumSamples);\n"
"    \n"
"    float2 dx           = ddx(TexCoord);\n"
"    float2 dy           = ddy(TexCoord);\n"
"    \n"
"    float2 OffsetStep   = Offset * StepSize;\n"
"    \n"
"    float2 CurOffset    = float2(0.0);\n"
"    float2 PrevOffset   = float2(0.0);\n"
"    float CurSample     = 0.0;\n"
"    float PrevSample    = 0.0;\n"
"    \n"
"    float StepHeight    = 1.0;\n"
"    int SampleIndex     = 0;\n"
"    \n"
"    while (SampleIndex < NumSamples)\n"
"    {\n"
"        #ifdef NORMALMAP_XYZ_H\n"
"        CurSample = tex2DGrad(NormalMap, TexCoord + CurOffset, dx, dy).a;\n"
"        #else\n"
"        CurSample = tex2DGrad(HeightMap, TexCoord + CurOffset, dx, dy).r;\n"
"        #endif\n"
"        \n"
"        if (CurSample > StepHeight)\n"
"        {\n"
"            float Ua = (PrevSample - (StepHeight + StepSize)) / (StepSize + (CurSample - PrevSample));\n"
"            CurOffset = PrevOffset + OffsetStep * Ua;\n"
"            break;\n"
"        }\n"
"        else\n"
"        {\n"
"            ++SampleIndex;\n"
"            StepHeight -= StepSize;\n"
"            PrevOffset = CurOffset;\n"
"            CurOffset += OffsetStep;\n"
"            PrevSample = CurSample;\n"
"        }\n"
"    }\n"
"    \n"
"    /* Sample diffuse color */\n"
"    DiffuseAndSpecular = tex2DGrad(DiffuseMap, TexCoord + CurOffset, dx, dy);\n"
"    \n"
"    /* Sample normal color */\n"
"    NormalAndDepth.xyz = tex2DGrad(NormalMap, TexCoord + CurOffset, dx, dy).rgb;\n"
"    \n"
"    /* Perform alpha-test clipping */\n"
"    //clip(Out.DiffuseAndSpecular.a - 0.5);\n"
"    \n"
"    #ifdef HAS_SPECULAR_MAP\n"
"    /* Sample specular color */\n"
"    DiffuseAndSpecular.a = tex2DGrad(SpecularMap, TexCoord + CurOffset, dx, dy).r * SpecularFactor;\n"
"    #endif\n"
"}\n"
"\n"
"#   endif // /PARALLAX_MAPPING\n"
"\n"
"/* Transform final normal vector into tangent-space */\n"
"NormalAndDepth.xyz = NormalAndDepth.xyz * float3(2.0) - float3(1.0);\n"
"MUL_NORMAL(NormalAndDepth.xyz);\n"
"\n"
"#endif // /NORMAL_MAPPING\n"
"\n"
"#ifndef HAS_SPECULAR_MAP\n"
"DiffuseAndSpecular.a = SpecularFactor;\n"
"#endif\n"
"\n"
"/* Compute depth distance between view position and pixel position */\n"
"NormalAndDepth.a = distance(ViewPosition, WorldPos);\n"
