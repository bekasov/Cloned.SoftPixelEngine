"/*\n"
" * GBuffer GLSL fragment shader file\n"
" * \n"
" * This file is part of the \"SoftPixel Engine\" (Copyright (c) 2008 by Lukas Hermanns)\n"
" * See \"SoftPixelEngine.hpp\" for license information.\n"
" */\n"
"\n"
"#version 120\n"
"\n"
"/*\n"
"\n"
"Compilation options:\n"
"\n"
"NORMAL_MAPPING      -> Enables normal mapping.\n"
"PARALLAX_MAPPING    -> Enables parallax-occlusion mapping (Requires NORMAL_MAPPING to be enabled).\n"
"NORMALMAP_XYZ_H        -> Normal map contains vector data (xyz in RGB) and height-field data (h in Alpha-Channel). When this is defined, no height-map is used for parallax-mapping.\n"
"HAS_SPECULAR_MAP    -> Specifies that a specular is used.\n"
"HAS_LIGHT_MAP        -> Specifies that a lightmap is used.\n"
"\n"
"*/\n"
"\n"
"#ifdef PARALLAX_MAPPING\n"
"#    ifdef GL_ARB_shader_texture_lod\n"
"#        extension GL_ARB_shader_texture_lod : enable\n"
"#    else\n"
"#        undef PARALLAX_MAPPING\n"
"#    endif\n"
"#endif\n"
"\n"
"/* === Uniforms === */\n"
"\n"
"uniform sampler2D DiffuseMap;\n"
"\n"
"#ifdef HAS_SPECULAR_MAP\n"
"uniform sampler2D SpecularMap;\n"
"#endif\n"
"\n"
"#ifdef HAS_LIGHT_MAP\n"
"uniform sampler2D LightMap;\n"
"uniform bool EnableLightMap;\n"
"#endif\n"
"\n"
"#ifdef NORMAL_MAPPING\n"
"\n"
"uniform sampler2D NormalMap;\n"
"#   if defined(PARALLAX_MAPPING) && !defined(NORMALMAP_XYZ_H)\n"
"// Contains only height-field information (in the alpha channel) when PARALLAX_MAPPING is enabled\n"
"uniform sampler2D HeightMap;\n"
"#   endif\n"
"\n"
"#   ifdef PARALLAX_MAPPING\n"
"\n"
"uniform bool EnablePOM;\n"
"uniform int MinSamplesPOM;\n"
"uniform int MaxSamplesPOM;\n"
"uniform float HeightMapScale;\n"
"uniform float ParallaxViewRange;\n"
"\n"
"#   endif\n"
"\n"
"#endif\n"
"\n"
"uniform float SpecularFactor;\n"
"\n"
"uniform vec3 ViewPosition;    //!< Global camera position.\n"
"\n"
"/* === Varyings === */\n"
"\n"
"varying vec3 WorldPos;\n"
"varying vec3 Normal;\n"
"varying vec2 TexCoord;\n"
"\n"
"#ifdef HAS_LIGHT_MAP\n"
"varying vec2 LMTexCoord;\n"
"#endif\n"
"\n"
"#ifdef NORMAL_MAPPING\n"
"varying vec3 Tangent;\n"
"varying vec3 Binormal;\n"
"#   ifdef PARALLAX_MAPPING\n"
"varying vec4 ViewVertexDirAndDepth;\n"
"#   endif\n"
"#endif\n"
"\n"
"/* === Functions === */\n"
"\n"
"void main()\n"
"{\n"
"    vec4 DiffuseAndSpecular = vec4(0.0);\n"
"    vec4 NormalAndDepth = vec4(0.0);\n"
"    \n"
"    #ifndef NORMAL_MAPPING\n"
"    \n"
"    /* Sample diffuse color */\n"
"    DiffuseAndSpecular = texture2D(DiffuseMap, TexCoord);\n"
"    \n"
"    #   ifdef HAS_SPECULAR_MAP\n"
"    /* Sample specular color */\n"
"    DiffuseAndSpecular.a = texture2D(SpecularMap, TexCoord).r * SpecularFactor;\n"
"    #   endif\n"
"    \n"
"    NormalAndDepth.xyz = Normal;\n"
"    \n"
"    #else\n"
"    \n"
"    #   ifdef PARALLAX_MAPPING\n"
"    if (!EnablePOM)\n"
"    {\n"
"    #   endif\n"
"        \n"
"        /* Sample diffuse color */\n"
"        DiffuseAndSpecular = texture2D(DiffuseMap, TexCoord);\n"
"        \n"
"        /* Perform alpha-test clipping */\n"
"        //if (DiffuseAndSpecular.a < 0.5)\n"
"        //    discard;\n"
"        \n"
"        /* Sample normal color */\n"
"        NormalAndDepth.xyz = texture2D(NormalMap, TexCoord).rgb;\n"
"        \n"
"        #ifdef HAS_SPECULAR_MAP\n"
"        /* Sample specular color */\n"
"        DiffuseAndSpecular.a = texture2D(SpecularMap, TexCoord).r * SpecularFactor;\n"
"        #endif\n"
"        \n"
"    #   ifdef PARALLAX_MAPPING\n"
"    }\n"
"    else\n"
"    {\n"
"        /* Compute parallax-occlusion displacement */\n"
"        float ParallaxLimit = (length(ViewVertexDirAndDepth.xy) / ViewVertexDirAndDepth.z) * HeightMapScale;\n"
"        \n"
"        vec2 Offset         = normalize(-ViewVertexDirAndDepth.xy) * ParallaxLimit;\n"
"        \n"
"        float Interpolation = clamp(ParallaxViewRange / ViewVertexDirAndDepth.w, 0.0, 1.0);\n"
"        int NumSamples      = int(mix(float(MinSamplesPOM), float(MaxSamplesPOM), Interpolation));\n"
"        \n"
"        float StepSize      = 1.0 / float(NumSamples);\n"
"        \n"
"        vec2 dx             = dFdx(TexCoord);\n"
"        vec2 dy             = dFdy(TexCoord);\n"
"        \n"
"        vec2 OffsetStep     = Offset * StepSize;\n"
"        \n"
"        vec2 CurOffset      = vec2(0.0);\n"
"        vec2 PrevOffset     = vec2(0.0);\n"
"        float CurSample     = 0.0;\n"
"        float PrevSample    = 0.0;\n"
"        \n"
"        float StepHeight    = 1.0;\n"
"        int SampleIndex     = 0;\n"
"        \n"
"        while (SampleIndex < NumSamples)\n"
"        {\n"
"            #ifdef NORMALMAP_XYZ_H\n"
"            CurSample = texture2DGradARB(NormalMap, TexCoord + CurOffset, dx, dy).a;\n"
"            #else\n"
"            CurSample = texture2DGradARB(HeightMap, TexCoord + CurOffset, dx, dy).r;\n"
"            #endif\n"
"            \n"
"            if (CurSample > StepHeight)\n"
"            {\n"
"                float Ua = (PrevSample - (StepHeight + StepSize)) / (StepSize + (CurSample - PrevSample));\n"
"                CurOffset = PrevOffset + OffsetStep * Ua;\n"
"                break;\n"
"            }\n"
"            else\n"
"            {\n"
"                ++SampleIndex;\n"
"                StepHeight -= StepSize;\n"
"                PrevOffset = CurOffset;\n"
"                CurOffset += OffsetStep;\n"
"                PrevSample = CurSample;\n"
"            }\n"
"        }\n"
"        \n"
"        /* Sample diffuse color */\n"
"        DiffuseAndSpecular = texture2DGradARB(DiffuseMap, TexCoord + CurOffset, dx, dy);\n"
"        \n"
"        /* Sample normal color */\n"
"        NormalAndDepth.xyz = texture2DGradARB(NormalMap, TexCoord + CurOffset, dx, dy).rgb;\n"
"        \n"
"        /* Perform alpha-test clipping */\n"
"        //if (DiffuseAndSpecular.a < 0.5)\n"
"        //    discard;\n"
"        \n"
"        #ifdef HAS_SPECULAR_MAP\n"
"        /* Sample specular color */\n"
"        DiffuseAndSpecular.a = texture2DGradARB(SpecularMap, TexCoord + CurOffset, dx, dy).r * SpecularFactor;\n"
"        #endif\n"
"    }\n"
"    \n"
"    #   endif // /PARALLAX_MAPPING\n"
"    \n"
"    /* Transform final normal vector into tangent-space */\n"
"    NormalAndDepth.xyz = NormalAndDepth.xyz * vec3(2.0) - vec3(1.0);\n"
"    \n"
"    vec3 FinalNormal = NormalAndDepth.xyz;\n"
"    NormalAndDepth.x = dot(FinalNormal, Tangent);\n"
"    NormalAndDepth.y = dot(FinalNormal, Binormal);\n"
"    NormalAndDepth.z = dot(FinalNormal, Normal);\n"
"    \n"
"    #endif // /NORMAL_MAPPING\n"
"    \n"
"    #ifndef HAS_SPECULAR_MAP\n"
"    DiffuseAndSpecular.a = SpecularFactor;\n"
"    #endif\n"
"    \n"
"    /* Compute depth distance between view position and pixel position */\n"
"    NormalAndDepth.a = distance(ViewPosition, WorldPos);\n"
"    \n"
"    /* Pass final output */\n"
"    gl_FragData[0] = DiffuseAndSpecular;\n"
"    gl_FragData[1] = NormalAndDepth;\n"
"    \n"
"    #ifdef HAS_LIGHT_MAP\n"
"    \n"
"    /* Sample illumination color */\n"
"    float Illumination = 1.0;\n"
"    \n"
"    if (EnableLightMap)\n"
"        Illumination = texture2D(LightMap, LMTexCoord).r;\n"
"    \n"
"    gl_FragData[2].r = Illumination;\n"
"    //DiffuseAndSpecular.rgb *= Illumination;//!!!\n"
"    \n"
"    #endif\n"
"}\n"
