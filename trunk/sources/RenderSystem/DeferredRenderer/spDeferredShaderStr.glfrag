"/*\n"
" * Deferred GLSL fragment shader file\n"
" * \n"
" * This file is part of the \"SoftPixel Engine\" (Copyright (c) 2008 by Lukas Hermanns)\n"
" * See \"SoftPixelEngine.hpp\" for license information.\n"
" */\n"
"\n"
"#version 120\n"
"\n"
"/*\n"
"\n"
"Compilation options:\n"
"\n"
"MAX_LIGHTS                -> Maximal count of light sources.\n"
"MAX_EX_LIGHTS            -> Maximal count of extended light sources (e.g. spot lights).\n"
"\n"
"SHADOW_MAPPING          -> Enables shadow mapping.\n"
"GLOBAL_ILLUMINATION        -> Enables global illumination (requires SHADOW_MAPPING).\n"
"BLOOM_FILTER            -> Enables bloom filter.\n"
"FLIP_Y_AXIS             -> Flips Y axis for OpenGL FBOs.\n"
"DEBUG_GBUFFER           -> Renders g-buffer for debugging.\n"
"DEBUG_GBUFFER_WORLDPOS    -> Renders position-map instead of depth map.\n"
"HAS_LIGHT_MAP            -> Specifies that a lightmap is used.\n"
"ALLOW_OVERBLENDING        -> Allows the lighting to ober-blend.\n"
"\n"
"*/\n"
"\n"
"#if defined(GL_EXT_texture_array) && defined(GL_ARB_texture_cube_map_array)\n"
"#    define TEXTURE_ARRAYS_SUPPORTED\n"
"#endif\n"
"\n"
"#if defined(TEXTURE_ARRAYS_SUPPORTED)\n"
"#    extension GL_EXT_texture_array : enable\n"
"#    extension GL_ARB_texture_cube_map_array : enable\n"
"#elif defined(SHADOW_MAPPING)\n"
"#    undef SHADOW_MAPPING\n"
"#endif\n"
"\n"
"/* === Macros === */\n"
"\n"
"#ifndef MAX_LIGHTS\n"
"#    define MAX_LIGHTS           35\n"
"#endif\n"
"#ifndef MAX_EX_LIGHTS\n"
"#    define MAX_EX_LIGHTS        15\n"
"#endif\n"
"\n"
"#define LIGHT_DIRECTIONAL       0\n"
"#define LIGHT_POINT             1\n"
"#define LIGHT_SPOT              2\n"
"\n"
"#define AMBIENT_LIGHT_FACTOR    0.0//0.1 //!< Should be in the range [0.0 .. 1.0].\n"
"\n"
"#define MIN_VARIANCE            1.0\n"
"\n"
"/* === Structures === */\n"
"\n"
"struct SLight\n"
"{\n"
"    vec4 PositionAndRadius;       //!< Position (xyz), Radius (w).\n"
"    vec3 Color;                   //!< Light color (used for diffuse and specular).\n"
"    int Type;                   //!< 0 -> Directional light, 1 -> Point light, 2 -> Spot light.\n"
"    int ShadowIndex;            //!< Shadow map layer index.\n"
"    int UsedForLightmaps;        //!< Specifies whether this light is used for lightmaps or not.\n"
"};\n"
"\n"
"struct SLightEx\n"
"{\n"
"    mat4 Projection;            //!< Spot-/ directional projection matrix.\n"
"    vec3 Direction;              //!< Spot-/ directional light direction.\n"
"    float SpotTheta;            //!< First spot cone angle (in radian).\n"
"    float SpotPhiMinusTheta;    //!< Second minus first spot cone angle (in radian).\n"
"    #ifdef GLOBAL_ILLUMINATION\n"
"    mat4 ViewTransform;            //!< View transformation matrix for reflective shadow maps.\n"
"    #endif\n"
"};\n"
"\n"
"/* === Uniforms === */\n"
"\n"
"uniform sampler2D DiffuseAndSpecularMap;\n"
"uniform sampler2D NormalAndDepthMap;\n"
"\n"
"#ifdef HAS_LIGHT_MAP\n"
"uniform sampler2D IlluminationMap;\n"
"#endif\n"
"\n"
"#ifdef SHADOW_MAPPING\n"
"\n"
"// Depth maps (for standard shadow maps)\n"
"uniform sampler2DArray DirLightShadowMaps;\n"
"uniform samplerCubeArray PointLightShadowMaps;\n"
"\n"
"#    ifdef GLOBAL_ILLUMINATION\n"
"// Diffuse maps (for reflective shadow maps)\n"
"uniform sampler2DArray DirLightDiffuseMaps;\n"
"uniform samplerCubeArray PointLightDiffuseMaps;\n"
"\n"
"// Normal maps (for reflective shadow maps)\n"
"uniform sampler2DArray DirLightNormalMaps;\n"
"uniform samplerCubeArray PointLightNormalMaps;\n"
"#    endif\n"
"\n"
"#endif\n"
"\n"
"uniform int LightCount;\n"
"uniform int LightExCount;\n"
"\n"
"uniform SLight Lights[MAX_LIGHTS];\n"
"uniform SLightEx LightsEx[MAX_EX_LIGHTS];\n"
"\n"
"uniform mat4 ViewTransform;    //!< Global camera transformation.\n"
"uniform vec3 ViewPosition;    //!< Global camera position.\n"
"uniform vec3 AmbientColor;    //!< Ambient light color.\n"
"uniform float ScreenWidth;    //!< Screen resolution width.\n"
"uniform float ScreenHeight;    //!< Screen resolution height.\n"
"\n"
"/* === Varyings === */\n"
"\n"
"varying vec2 TexCoord;\n"
"\n"
"/* === Functions === */\n"
"\n"
"float GetAngle(in vec3 a, in vec3 b)\n"
"{\n"
"    return acos(dot(a, b));\n"
"}\n"
"\n"
"void Frustum(inout float x, inout float y, in float w, in float h)\n"
"{\n"
"    float aspect = (w*3.0) / (h*4.0);\n"
"    x = (x - w*0.5) / (w*0.5) * aspect;\n"
"    y = (y - h*0.5) / (w*0.5) * aspect;\n"
"}\n"
"\n"
"#ifdef SHADOW_MAPPING\n"
"\n"
"// Chebyshev inequality function for VSM (variance shadow maps)\n"
"// see GPUGems3 at nVIDIA for more details: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch08.html\n"
"float ChebyshevUpperBound(in vec2 Moments, in float t)\n"
"{\n"
"    /* One-tailed inequality valid if t > Moments.x */\n"
"    float p = step(t, Moments.x);\n"
"    \n"
"    /* Compute variance */\n"
"    float Variance = Moments.y - (Moments.x*Moments.x);\n"
"    Variance = max(Variance, MIN_VARIANCE);\n"
"    \n"
"    /* Compute probabilistic upper bound. */\n"
"    float d = t - Moments.x;\n"
"    float p_max = Variance / (Variance + d*d);\n"
"    \n"
"    return max(p, p_max);\n"
"}\n"
"\n"
"float LinStep(in float min, in float max, in float v)\n"
"{\n"
"    return clamp((v - min) / (max - min), 0.0, 1.0);\n"
"}\n"
"\n"
"float ReduceLightBleeding(in float p_max, in float Amount)\n"
"{\n"
"    /* remove the [0, amount] ail and linearly rescale [amount, 1] */\n"
"    return LinStep(Amount, 1.0, p_max);\n"
"}\n"
"\n"
"float ShadowContribution(in vec2 Moments, in float LightDistance)\n"
"{\n"
"    /* Compute the Chebyshev upper bound */\n"
"    float p_max = ChebyshevUpperBound(Moments, LightDistance);\n"
"    return ReduceLightBleeding(p_max, 0.6);\n"
"}\n"
"\n"
"vec4 Projection(in mat4 ProjectionMatrix, in vec4 Point)\n"
"{\n"
"    vec4 ProjectedPoint = ProjectionMatrix * Point;\n"
"\n"
"    ProjectedPoint.xy = (ProjectedPoint.xy / vec2(ProjectedPoint.w) + vec2(1.0)) * vec2(0.5);\n"
"\n"
"    return ProjectedPoint;\n"
"}\n"
"\n"
"#endif\n"
"\n"
"void ComputeLightShading(\n"
"    in SLight Light, in SLightEx LightEx,\n"
"    in vec3 Point, in vec3 Normal, in float Shininess, in vec3 ViewDir,\n"
"    #ifdef HAS_LIGHT_MAP\n"
"    inout vec3 StaticDiffuseColor, inout vec3 StaticSpecularColor,\n"
"    #endif\n"
"    inout vec3 DiffuseColor, inout vec3 SpecularColor)\n"
"{\n"
"    /* Compute light direction vector */\n"
"    vec3 LightDir = vec3(0.0);\n"
"\n"
"    if (Light.Type != LIGHT_DIRECTIONAL)\n"
"        LightDir = normalize(Point - Light.PositionAndRadius.xyz);\n"
"    else\n"
"        LightDir = LightEx.Direction;\n"
"\n"
"    /* Compute phong shading */\n"
"    float NdotL = max(AMBIENT_LIGHT_FACTOR, -dot(Normal, LightDir));\n"
"\n"
"    /* Compute light attenuation */\n"
"    float Distance = distance(Point, Light.PositionAndRadius.xyz);\n"
"\n"
"    float AttnLinear    = Distance / Light.PositionAndRadius.w;\n"
"    float AttnQuadratic = AttnLinear * Distance;\n"
"\n"
"    float Intensity = 1.0 / (1.0 + AttnLinear + AttnQuadratic);\n"
"\n"
"    if (Light.Type == LIGHT_SPOT)\n"
"    {\n"
"        /* Compute spot light cone */\n"
"        float Angle = GetAngle(LightDir, LightEx.Direction);\n"
"        float ConeAngleLerp = (Angle - LightEx.SpotTheta) / LightEx.SpotPhiMinusTheta;\n"
"\n"
"        Intensity *= clamp(1.0 - ConeAngleLerp, 0.0, 1.0);\n"
"    }\n"
"\n"
"    /* Compute diffuse color */\n"
"    vec3 Diffuse = Light.Color * vec3(Intensity * NdotL);\n"
"\n"
"    /* Compute specular color */\n"
"    vec3 Reflection = normalize(reflect(LightDir, Normal));\n"
"\n"
"    float NdotHV = -dot(ViewDir, Reflection);\n"
"\n"
"    vec3 Specular = Light.Color * vec3(Intensity * pow(max(0.0, NdotHV), Shininess));\n"
"\n"
"    #ifdef SHADOW_MAPPING\n"
"    \n"
"    /* Apply shadow */\n"
"    if (Light.ShadowIndex != -1)\n"
"    {\n"
"        if (Light.Type == LIGHT_POINT)\n"
"        {\n"
"            //todo\n"
"        }\n"
"        else if (Light.Type == LIGHT_SPOT)\n"
"        {\n"
"            /* Get shadow map texture coordinate */\n"
"            vec4 ShadowTexCoord = Projection(LightEx.Projection, vec4(Point, 1.0));\n"
"            \n"
"            if ( ShadowTexCoord.x >= 0.0 && ShadowTexCoord.x <= 1.0 &&\n"
"                 ShadowTexCoord.y >= 0.0 && ShadowTexCoord.y <= 1.0 &&\n"
"                 ShadowTexCoord.z < 0.0 )\n"
"            {\n"
"                /* Adjust texture coordinate */\n"
"                ShadowTexCoord.x = 1.0 - ShadowTexCoord.x;\n"
"                ShadowTexCoord.z = float(Light.ShadowIndex);\n"
"                ShadowTexCoord.w = 2.0;\n"
"                \n"
"                /* Sample moments from shadow map */\n"
"                vec2 Moments = texture2DArrayLod(DirLightShadowMaps, ShadowTexCoord.xyz, ShadowTexCoord.w).ra;\n"
"                \n"
"                /* Compute shadow contribution */\n"
"                float Shadow = ShadowContribution(Moments, Distance);\n"
"                \n"
"                Diffuse *= vec3(Shadow);\n"
"                Specular *= vec3(Shadow);\n"
"            }\n"
"            \n"
"            #ifdef GLOBAL_ILLUMINATION\n"
"            \n"
"            /* Compute indirect lights */\n"
"            vec3 IndirectTexCoord = vec3(0.0, 0.0, float(Light.ShadowIndex));\n"
"            \n"
"            for (int i = 0; i < 10; ++i)\n"
"            {\n"
"                IndirectTexCoord.x = float(i) * 0.1;\n"
"                \n"
"                for (int j = 0; j < 10; ++j)\n"
"                {\n"
"                    IndirectTexCoord.y = float(j) * 0.1;\n"
"                    \n"
"                    /* Get color and normal from indirect light */\n"
"                    float IndirectDist    = texture2DArray(DirLightShadowMaps, IndirectTexCoord).r;\n"
"                    vec3 IndirectColor    = texture2DArray(DirLightDiffuseMaps, IndirectTexCoord).rgb;\n"
"                    vec3 IndirectNormal    = texture2DArray(DirLightNormalMaps, IndirectTexCoord).rgb;\n"
"                    \n"
"                    IndirectNormal = IndirectNormal * vec3(2.0) - vec3(1.0);\n"
"                    \n"
"                    /* Get the indirect light's position */\n"
"                    vec3 IndirectPoint = normalize(vec3(IndirectTexCoord.x*2.0 - 1.0, IndirectTexCoord.y*2.0 - 1.0, 1.0));\n"
"                    IndirectPoint = (LightEx.ViewTransform * vec4(IndirectPoint * vec3(IndirectDist), 1.0)).xyz;\n"
"                    \n"
"                    /* Compute phong shading for indirect light */\n"
"                    float NdotIL = max(0.0, -dot(Normal, IndirectNormal));\n"
"                    \n"
"                    /* Compute light attenuation */\n"
"                    float DistanceIL = distance(Point, IndirectPoint);\n"
"                    \n"
"                    float AttnLinearIL    = DistanceIL / 0.1;\n"
"                    float AttnQuadraticIL = AttnLinearIL * DistanceIL;\n"
"                    \n"
"                    float IntensityIL = 1.0 / (1.0 + AttnLinearIL + AttnQuadraticIL);\n"
"                    \n"
"                    /* Shade indirect light */\n"
"                    Diffuse += Light.Color * IndirectColor * vec3(IntensityIL * NdotIL);\n"
"                }\n"
"            }\n"
"            \n"
"            #endif\n"
"        }\n"
"    }\n"
"\n"
"    #endif\n"
"\n"
"    /* Add light color */\n"
"    #ifdef HAS_LIGHT_MAP\n"
"    \n"
"    if (Light.UsedForLightmaps != 0)\n"
"    {\n"
"        StaticDiffuseColor += Diffuse;\n"
"        StaticSpecularColor += Specular;\n"
"    }\n"
"    else\n"
"    {\n"
"        DiffuseColor += Diffuse;\n"
"        SpecularColor += Specular;\n"
"    }\n"
"    \n"
"    #else\n"
"    \n"
"    DiffuseColor += Diffuse;\n"
"    SpecularColor += Specular;\n"
"    \n"
"    #endif\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    vec2 TexCoord = TexCoord;\n"
"    vec2 WinCoord = gl_FragCoord.xy;\n"
"    \n"
"    #ifdef DEBUG_GBUFFER\n"
"\n"
"    TexCoord *= vec2(2.0);\n"
"    WinCoord *= vec2(2.0);\n"
"\n"
"    vec2 debTexCoord = TexCoord;\n"
"\n"
"    if (TexCoord.x > 1.0) TexCoord.x -= 1.0;\n"
"    if (TexCoord.y > 1.0) TexCoord.y -= 1.0;\n"
"\n"
"    if (WinCoord.x > ScreenWidth) WinCoord.x -= ScreenWidth;\n"
"    if (WinCoord.y > ScreenHeight) WinCoord.y -= ScreenHeight;\n"
"\n"
"    #endif\n"
"    \n"
"    /* Get texture colors */\n"
"    vec4 DiffuseAndSpecular = texture2D(DiffuseAndSpecularMap, TexCoord);\n"
"    vec4 NormalAndDepthDist = texture2D(NormalAndDepthMap, TexCoord);\n"
"    \n"
"    /* Compute global pixel position */\n"
"    #ifdef FLIP_Y_AXIS\n"
"    vec4 Point = vec4(WinCoord.x, ScreenHeight - WinCoord.y, 1.0, 1.0);\n"
"    #else\n"
"    vec4 Point = vec4(WinCoord.x, WinCoord.y, 1.0, 1.0);\n"
"    #endif\n"
"    \n"
"    Frustum(Point.x, Point.y, ScreenWidth, ScreenHeight);\n"
"\n"
"    Point.xyz = normalize(Point.xyz) * vec3(NormalAndDepthDist.a);\n"
"    Point = ViewTransform * Point;\n"
"\n"
"    /* Compute light shading */\n"
"    #ifdef HAS_LIGHT_MAP\n"
"    vec3 StaticDiffuseLight = vec3(0.0);\n"
"    vec3 StaticSpecularLight = vec3(0.0);\n"
"    #endif\n"
"    \n"
"    vec3 DiffuseLight = AmbientColor;\n"
"    vec3 SpecularLight = vec3(0.0);\n"
"    \n"
"    vec3 ViewDir = normalize(Point.xyz - ViewPosition);\n"
"    \n"
"    for (int i = 0, j = 0; i < LightCount; ++i)\n"
"    {\n"
"        ComputeLightShading(\n"
"            Lights[i], LightsEx[j], Point.xyz, NormalAndDepthDist.xyz, 90.0, ViewDir,\n"
"            #ifdef HAS_LIGHT_MAP\n"
"            StaticDiffuseLight, StaticSpecularLight,\n"
"            #endif\n"
"            DiffuseLight, SpecularLight\n"
"        );\n"
"        \n"
"        if (Lights[i].Type != LIGHT_POINT)\n"
"            ++j;\n"
"    }\n"
"    \n"
"    #ifdef HAS_LIGHT_MAP\n"
"    \n"
"    /* Mix light shading with light-map illumination */\n"
"    float Illumination = texture2D(IlluminationMap, TexCoord).r;\n"
"    \n"
"    DiffuseLight += (StaticDiffuseLight * vec3(Illumination));\n"
"    SpecularLight += (StaticSpecularLight * vec3(Illumination));\n"
"    \n"
"    #endif\n"
"    \n"
"    #ifndef ALLOW_OVERBLENDING\n"
"    DiffuseLight = clamp(DiffuseLight, vec3(0.0), vec3(1.0));\n"
"    SpecularLight = clamp(SpecularLight, vec3(0.0), vec3(1.0));\n"
"    #endif\n"
"    \n"
"    DiffuseLight *= DiffuseAndSpecular.rgb;\n"
"    SpecularLight *= vec3(DiffuseAndSpecular.a);\n"
"    \n"
"    /* Compute final deferred shaded pixel color */\n"
"    gl_FragData[0].rgb    = DiffuseLight + SpecularLight;\n"
"    gl_FragData[0].a    = 1.0;\n"
"    \n"
"    #ifdef BLOOM_FILTER\n"
"    gl_FragData[1].rgb    = SpecularLight;\n"
"    gl_FragData[1].a    = 1.0;\n"
"    #endif\n"
"    \n"
"    #ifdef DEBUG_GBUFFER\n"
"\n"
"    if (debTexCoord.x > 1.0)\n"
"    {\n"
"        if (debTexCoord.y > 1.0)\n"
"            gl_FragData[0].rgb = texture2D(NormalAndDepthMap, TexCoord).rgb * vec3(0.5) + vec3(0.5);\n"
"        else\n"
"            gl_FragData[0].rgb = DiffuseAndSpecular.rgb;\n"
"    }\n"
"    else\n"
"    {\n"
"        if (debTexCoord.y > 1.0)\n"
"        {\n"
"            #ifdef DEBUG_GBUFFER_WORLDPOS\n"
"            gl_FragData[0].rgb = Point.xyz * vec3(0.025);\n"
"            #else\n"
"            gl_FragData[0].rgb = vec3(NormalAndDepthDist.a * 0.025);\n"
"            #endif\n"
"        }\n"
"    }\n"
"\n"
"    #endif\n"
"}\n"
