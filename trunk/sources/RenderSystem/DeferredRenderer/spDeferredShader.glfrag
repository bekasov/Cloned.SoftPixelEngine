/*
 * Deferred GLSL fragment shader file
 * 
 * This file is part of the "SoftPixel Engine" (Copyright (c) 2008 by Lukas Hermanns)
 * See "SoftPixelEngine.hpp" for license information.
 */

#version 120

/*

Compilation options:

SHADOW_MAPPING  		-> Enables shadow mapping.
BLOOM_FILTER    		-> Enables bloom filter.
FLIP_Y_AXIS     		-> Flips Y axis for OpenGL FBOs.
DEBUG_GBUFFER   		-> Renders g-buffer for debugging.
DEBUG_GBUFFER_WORLDPOS	-> Renders position-map instead of depth map.
HAS_LIGHT_MAP			-> Specifies that a lightmap is used.
ALLOW_OVERBLENDING		-> Allows the lighting to ober-blend.

*/

#if defined(GL_EXT_texture_array) && defined(GL_ARB_texture_cube_map_array)
#	define TEXTURE_ARRAYS_SUPPORTED
#endif

#if defined(TEXTURE_ARRAYS_SUPPORTED)
#	extension GL_EXT_texture_array : enable
#	extension GL_ARB_texture_cube_map_array : enable
#elif defined(SHADOW_MAPPING)
#	undef SHADOW_MAPPING
#endif

/* === Macros === */

#define MAX_LIGHTS              35
#define MAX_EX_LIGHTS           15

#define LIGHT_DIRECTIONAL       0
#define LIGHT_POINT             1
#define LIGHT_SPOT              2

#define AMBIENT_LIGHT_FACTOR    0.0//0.1 //!< Should be in the range [0.0 .. 1.0].

#define MIN_VARIANCE            1.0

/* === Structures === */

struct SLight
{
    vec4 PositionAndRadius;   	//!< Position (xyz), Radius (w).
    vec3 Color;               	//!< Light color (used for diffuse and specular).
    int Type;                   //!< 0 -> Directional light, 1 -> Point light, 2 -> Spot light.
    int ShadowIndex;            //!< Shadow map layer index.
	int UsedForLightmaps;		//!< Specifies whether this light is used for lightmaps or not.
};

struct SLightEx
{
    mat4 Projection;        	//!< Spot-/ directional projection matrix.
    vec3 Direction;          	//!< Spot-/ directional light direction.
    float SpotTheta;			//!< First spot cone angle (in radian).
    float SpotPhiMinusTheta;	//!< Second minus first spot cone angle (in radian).
};

/* === Uniforms === */

uniform sampler2D DiffuseAndSpecularMap;
uniform sampler2D NormalAndDepthMap;

#ifdef HAS_LIGHT_MAP
uniform sampler2D IlluminationMap;
#endif

#ifdef SHADOW_MAPPING
uniform sampler2DArray DirLightShadowMaps;
uniform samplerCubeArray PointLightShadowMaps;
#endif

uniform int LightCount;
uniform int LightExCount;

uniform SLight Lights[MAX_LIGHTS];
uniform SLightEx LightsEx[MAX_EX_LIGHTS];

uniform mat4 ViewTransform;	//!< Global camera transformation.
uniform vec3 ViewPosition;	//!< Global camera position.
uniform vec3 AmbientColor;	//!< Ambient light color.
uniform float ScreenWidth;	//!< Screen resolution width.
uniform float ScreenHeight;	//!< Screen resolution height.

/* === Functions === */

float GetAngle(vec3 a, vec3 b)
{
    return acos(dot(a, b));
}

void Frustum(inout float x, inout float y, float w, float h)
{
    float aspect = (w*3.0) / (h*4.0);
    x = (x - w*0.5) / (w*0.5) * aspect;
    y = (y - h*0.5) / (w*0.5) * aspect;
}

#ifdef SHADOW_MAPPING

// Chebyshev inequality function for VSM (variance shadow maps)
// see GPUGems3 at nVIDIA for more details: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch08.html
float ChebyshevUpperBound(vec2 Moments, float t)
{
    /* One-tailed inequality valid if t > Moments.x */
	float p = step(t, Moments.x);
	
    /* Compute variance */
    float Variance = Moments.y - (Moments.x*Moments.x);
    Variance = max(Variance, MIN_VARIANCE);
    
    /* Compute probabilistic upper bound. */
    float d = t - Moments.x;
    float p_max = Variance / (Variance + d*d);
    
    return max(p, p_max);
}

float LinStep(float min, float max, float v)
{
    return clamp((v - min) / (max - min), 0, 1);
}

float ReduceLightBleeding(float p_max, float Amount)
{
    /* remove the [0, amount] ail and linearly rescale [amount, 1] */
    return LinStep(Amount, 1.0, p_max);
}

float ShadowContribution(vec2 Moments, float LightDistance)
{
    /* Compute the Chebyshev upper bound */
    float p_max = ChebyshevUpperBound(Moments, LightDistance);
    return ReduceLightBleeding(p_max, 0.6);
}

vec4 Projection(mat4 ProjectionMatrix, vec4 Point)
{
    vec4 ProjectedPoint = ProjectionMatrix * Point;

    ProjectedPoint.xy = (ProjectedPoint.xy / vec2(ProjectedPoint.w) + vec2(1.0)) * vec2(0.5);

    return ProjectedPoint;
}

#endif

void ComputeLightShading(
    SLight Light, SLightEx LightEx,
    vec3 Point, vec3 Normal, float Shininess,
	#ifdef HAS_LIGHT_MAP
	inout vec3 StaticDiffuseColor, inout vec3 StaticSpecularColor,
	#endif
    inout vec3 DiffuseColor, inout vec3 SpecularColor)
{
    /* Compute light direction vector */
    vec3 LightDir = vec3(0.0);

    if (Light.Type != LIGHT_DIRECTIONAL)
        LightDir = normalize(Point - Light.PositionAndRadius.xyz);
    else
        LightDir = LightEx.Direction;

    /* Compute phong shading */
    float NdotL = max(AMBIENT_LIGHT_FACTOR, -dot(Normal, LightDir));

    /* Compute light attenuation */
    float Distance = distance(Point, Light.PositionAndRadius.xyz);

    float AttnLinear    = Distance / Light.PositionAndRadius.w;
    float AttnQuadratic = AttnLinear * Distance;

    float Intensity = 1.0 / (1.0 + AttnLinear + AttnQuadratic);

    if (Light.Type == LIGHT_SPOT)
    {
        /* Compute spot light cone */
        float Angle = GetAngle(LightDir, LightEx.Direction);
        float ConeAngleLerp = (Angle - LightEx.SpotTheta) / LightEx.SpotPhiMinusTheta;

        Intensity *= clamp(1.0 - ConeAngleLerp, 0.0, 1.0);
    }

    /* Compute diffuse color */
    vec3 Diffuse = Light.Color * vec3(Intensity * NdotL);

    /* Compute specular color */
    vec3 ViewDir      = normalize(Point - ViewPosition);
    vec3 Reflection   = normalize(reflect(LightDir, Normal));

    float NdotHV = -dot(ViewDir, Reflection);

    vec3 Specular = Light.Color * vec3(Intensity * pow(max(0.0, NdotHV), Shininess));

    #ifdef SHADOW_MAPPING
	
    /* Apply shadow */
    if (Light.ShadowIndex != -1)
    {
        if (Light.Type == LIGHT_POINT)
        {
            //todo
        }
        else if (Light.Type == LIGHT_SPOT)
        {
            /* Get shadow map texture coordinate */
            vec4 ShadowTexCoord = Projection(LightEx.Projection, vec4(Point, 1.0));

            if ( ShadowTexCoord.x >= 0.0 && ShadowTexCoord.x <= 1.0 &&
                 ShadowTexCoord.y >= 0.0 && ShadowTexCoord.y <= 1.0 &&
                 ShadowTexCoord.z < 0.0 )
            {
                /* Adjust texture coordinate */
                ShadowTexCoord.x = 1.0 - ShadowTexCoord.x;
                ShadowTexCoord.z = float(Light.ShadowIndex);
                ShadowTexCoord.w = 2.0;
				
                /* Sample moments from shadow map */
                vec2 Moments = texture2DArrayLod(DirLightShadowMaps, ShadowTexCoord.xyz, ShadowTexCoord.w).ra;
				
                /* Compute shadow contribution */
                float Shadow = ShadowContribution(Moments, Distance);
				
                Diffuse *= vec3(Shadow);
                Specular *= vec3(Shadow);
            }
        }
    }

    #endif

    /* Add light color */
	#ifdef HAS_LIGHT_MAP
	
	if (Light.UsedForLightmaps != 0)
	{
		StaticDiffuseColor += Diffuse;
		StaticSpecularColor += Specular;
	}
	else
	{
		DiffuseColor += Diffuse;
		SpecularColor += Specular;
	}
	
	#else
	
    DiffuseColor += Diffuse;
    SpecularColor += Specular;
	
	#endif
}

void main()
{
    vec2 TexCoord = gl_TexCoord[0].xy;
    vec2 WinCoord = gl_FragCoord.xy;
    
    #ifdef DEBUG_GBUFFER

    TexCoord *= vec2(2.0);
    WinCoord *= vec2(2.0);

    vec2 debTexCoord = TexCoord;

    if (TexCoord.x > 1.0) TexCoord.x -= 1.0;
    if (TexCoord.y > 1.0) TexCoord.y -= 1.0;

    if (WinCoord.x > ScreenWidth) WinCoord.x -= ScreenWidth;
    if (WinCoord.y > ScreenHeight) WinCoord.y -= ScreenHeight;

    #endif
    
    /* Get texture colors */
    vec4 DiffuseAndSpecular = texture2D(DiffuseAndSpecularMap, TexCoord);
    vec4 NormalAndDepthDist = texture2D(NormalAndDepthMap, TexCoord);
	
    /* Compute global pixel position */
    #ifdef FLIP_Y_AXIS
    vec4 Point = vec4(WinCoord.x, ScreenHeight - WinCoord.y, 1.0, 1.0);
    #else
    vec4 Point = vec4(WinCoord.x, WinCoord.y, 1.0, 1.0);
    #endif
	
    Frustum(Point.x, Point.y, ScreenWidth, ScreenHeight);

    Point.xyz = normalize(Point.xyz) * vec3(NormalAndDepthDist.a);
    Point = ViewTransform * Point;

    /* Compute light shading */
	#ifdef HAS_LIGHT_MAP
    vec3 StaticDiffuseLight = vec3(0.0);
    vec3 StaticSpecularLight = vec3(0.0);
    #endif
	
    vec3 DiffuseLight = AmbientColor;
    vec3 SpecularLight = vec3(0.0);
	
    for (int i = 0, j = 0; i < LightCount; ++i)
    {
		ComputeLightShading(
			Lights[i], LightsEx[j], Point.xyz, NormalAndDepthDist.xyz, 90.0,
			#ifdef HAS_LIGHT_MAP
			StaticDiffuseLight, StaticSpecularLight,
			#endif
			DiffuseLight, SpecularLight
		);
        
        if (Lights[i].Type != LIGHT_POINT)
            ++j;
    }
	
	#ifdef HAS_LIGHT_MAP
	
	/* Mix light shading with light-map illumination */
	float Illumination = texture2D(IlluminationMap, TexCoord).r;
	
	DiffuseLight += (StaticDiffuseLight * vec3(Illumination));
	SpecularLight += (StaticSpecularLight * vec3(Illumination));
	
	#endif
	
	#ifndef ALLOW_OVERBLENDING
	DiffuseLight = clamp(DiffuseLight, vec3(0.0), vec3(1.0));
	SpecularLight = clamp(SpecularLight, vec3(0.0), vec3(1.0));
	#endif
	
    DiffuseLight *= DiffuseAndSpecular.rgb;
    SpecularLight *= vec3(DiffuseAndSpecular.a);
	
    /* Compute final deferred shaded pixel color */
    gl_FragData[0].rgb	= DiffuseLight + SpecularLight;
    gl_FragData[0].a	= 1.0;
	
	#ifdef BLOOM_FILTER
    gl_FragData[1].rgb	= SpecularLight;
    gl_FragData[1].a	= 1.0;
    #endif
    
    #ifdef DEBUG_GBUFFER

    if (debTexCoord.x > 1.0)
    {
        if (debTexCoord.y > 1.0)
            gl_FragData[0].rgb = texture2D(NormalAndDepthMap, TexCoord).rgb * vec3(0.5) + vec3(0.5);
        else
            gl_FragData[0].rgb = DiffuseAndSpecular.rgb;
    }
    else
    {
        if (debTexCoord.y > 1.0)
		{
			#ifdef DEBUG_GBUFFER_WORLDPOS
            gl_FragData[0].rgb = Point.xyz * vec3(0.025);
			#else
            gl_FragData[0].rgb = vec3(NormalAndDepthDist.a * 0.025);
			#endif
		}
    }

    #endif
}
