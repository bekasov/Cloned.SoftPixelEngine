/*
 * Deferred GLSL fragment shader file
 * 
 * This file is part of the "SoftPixel Engine" (Copyright (c) 2008 by Lukas Hermanns)
 * See "SoftPixelEngine.hpp" for license information.
 */

#version 140

#include "spDeferredShaderHeader.shader"

/*

Compilation options:

MAX_LIGHTS				-> Maximal count of light sources.
MAX_EX_LIGHTS			-> Maximal count of extended light sources (e.g. spot lights).

SHADOW_MAPPING  		-> Enables shadow mapping.
GLOBAL_ILLUMINATION		-> Enables global illumination (requires SHADOW_MAPPING).
BLOOM_FILTER    		-> Enables bloom filter.
TILED_SHADING			-> Enables tiled deferred shading.
DEBUG_GBUFFER   		-> Renders g-buffer for debugging.
DEBUG_GBUFFER_WORLDPOS	-> Renders position-map instead of depth map.
HAS_LIGHT_MAP			-> Specifies that a lightmap is used.
ALLOW_OVERBLENDING		-> Allows the lighting to ober-blend.

*/

#extension GL_ARB_explicit_attrib_location : enable

#ifdef SHADOW_MAPPING
#	extension GL_EXT_texture_array : enable
#	extension GL_ARB_texture_cube_map_array : enable
#	ifdef GLOBAL_ILLUMINATION
#		extension GL_EXT_gpu_shader4 : enable
#	endif
#endif

/* === Uniforms === */

uniform sampler2D DiffuseAndSpecularMap;
uniform sampler2D NormalAndDepthMap;

#ifdef HAS_LIGHT_MAP
uniform sampler2D IlluminationMap;
#endif

#if defined(GLOBAL_ILLUMINATION) && defined(USE_LOWRES_VPL_SHADING)
uniform sampler2D VPLColorMap;
#endif

#ifdef SHADOW_MAPPING

// Shadow maps (for standard shadow maps)
uniform sampler2DArray DirLightShadowMaps;
uniform samplerCubeArray PointLightShadowMaps;

#	ifdef GLOBAL_ILLUMINATION
// Diffuse maps (for reflective shadow maps)
uniform sampler2DArray DirLightDiffuseMaps;
uniform samplerCubeArray PointLightDiffuseMaps;

// Normal maps (for reflective shadow maps)
//uniform sampler2DArray DirLightNormalMaps;
//uniform samplerCubeArray PointLightNormalMaps;
#	endif

#endif

#ifdef TILED_SHADING

// Dynamic tile light index list and 2D tile grid (for tiled deferred shading)
uniform isamplerBuffer TileLightIndexList;

layout(std140) uniform LightGridBlock
{
	ivec4 LightGrid[TILED_LIGHT_GRID_NUM_X * TILED_LIGHT_GRID_NUM_Y];
};

#endif

#ifdef GLOBAL_ILLUMINATION

uniform float GIReflectivity;

layout(std140) uniform VPLOffsetBlock
{
	float4 VPLOffsets[100];
};

#endif

uniform int LightCount;

#ifdef LIGHT_CONSTANT_BUFFERS

layout(std140) uniform LightBlock
{
	SLight Lights[MAX_LIGHTS];
};

layout(std140) uniform LightExBlock
{
	SLightEx LightsEx[MAX_EX_LIGHTS];
};

#else

uniform SLight Lights[MAX_LIGHTS];
uniform SLightEx LightsEx[MAX_EX_LIGHTS];

#endif

uniform float3 ViewPosition;		//!< Global camera position.
uniform float3 AmbientColor;		//!< Ambient light color.

/* === Varyings === */

in float2 TexCoord;
in float4 ViewRay;

layout(location = 0) out float4 OutColor;

#ifdef BLOOM_FILTER
layout(location = 1) out float4 OutSpecular;
#endif


/* === Functions === */

#include "spDeferredShaderProcs.shader"

void main()
{
    /* Compute global pixel position (world space) */
    float4 NormalAndDepthDist = tex2D(NormalAndDepthMap, TexCoord);
	
	float3 ViewRayNorm = normalize(ViewRay.xyz);
    float3 WorldPos = ViewPosition + ViewRayNorm * float3(NormalAndDepthDist.a);
	
    /* Compute light shading */
	#ifdef HAS_LIGHT_MAP
    float3 StaticDiffuseLight = float3(0.0);
    float3 StaticSpecularLight = float3(0.0);
    #endif
	
    float3 DiffuseLight = AmbientColor;
    float3 SpecularLight = float3(0.0);
	
	#ifdef TILED_SHADING
	
	/* Get light count and offset from the tiled light grid */
	ivec2 LightGridIndex = ivec2(
		int(gl_FragCoord.x) / TILED_LIGHT_GRID_WIDTH,
		int(gl_FragCoord.y) / TILED_LIGHT_GRID_HEIGHT
	);
	//ivec2 LightCountAndOffset = LightGrid[LightGridIndex.x + LightGridIndex.y * TILED_LIGHT_GRID_NUM_X].xy;
	ivec2 LightCountAndOffset = ivec2(50, 0);//!!!
	
	for (int l = 0; l < LightCountAndOffset.x; ++l)
	{
		/* Get light indices from the tile light index list */
		ivec2 TileLightIndices = texelFetch(TileLightIndexList, LightCountAndOffset.y + l).xy;
		
		int i = TileLightIndices.x;
		int j = TileLightIndices.y;
		
		#if 1//!!!
		i = clamp(i, 0, 49);
		j = 0;
		if (LightGridIndex.x % 2 == 0 || LightGridIndex.y % 2 == 0)
			i = l;
		#endif
		
	#else
	for (int i = 0, j = 0; i < LightCount; ++i)
	{
	#endif
		ComputeLightShading(
			Lights[i], LightsEx[j], WorldPos, NormalAndDepthDist.xyz, 90.0, ViewRayNorm,
			#ifdef HAS_LIGHT_MAP
			StaticDiffuseLight, StaticSpecularLight,
			#endif
			DiffuseLight, SpecularLight
		);
		
		#ifndef TILED_SHADING
		if (Lights[i].Type != LIGHT_POINT)
			++j;
		#endif
	}
	
	#ifdef HAS_LIGHT_MAP
	
	/* Mix light shading with light-map illumination */
	float Illumination = tex2D(IlluminationMap, TexCoord).r;
	
	DiffuseLight += (StaticDiffuseLight * float3(Illumination));
	SpecularLight += (StaticSpecularLight * float3(Illumination));
	
	#endif
	
	#if defined(GLOBAL_ILLUMINATION) && defined(USE_LOWRES_VPL_SHADING)
	
	/* Apply global illumination color from VPLs */
	DiffuseLight += tex2D(VPLColorMap, TexCoord).rgb;
	
	#endif
	
	#ifndef ALLOW_OVERBLENDING
	DiffuseLight = saturate(DiffuseLight);
	SpecularLight = saturate(SpecularLight);
	#endif
	
    /* Get diffuse and specular colors */
	float4 DiffuseAndSpecular = tex2D(DiffuseAndSpecularMap, TexCoord);
	
    DiffuseLight *= DiffuseAndSpecular.rgb;
    SpecularLight *= float3(DiffuseAndSpecular.a);
	
    /* Compute final deferred shaded pixel color */
    OutColor.rgb	= DiffuseLight + SpecularLight;
    OutColor.a		= 1.0;
	
	#ifdef BLOOM_FILTER
    OutSpecular.rgb	= SpecularLight;
    OutSpecular.a	= 1.0;
    #endif
    
    #ifdef DEBUG_GBUFFER
	
    /*if (debTexCoord.x > 1.0)
    {
        if (debTexCoord.y > 1.0)
            OutColor.rgb = tex2D(NormalAndDepthMap, TexCoord).rgb * float3(0.5) + float3(0.5);
        else
            OutColor.rgb = DiffuseAndSpecular.rgb;
    }
    else
    {
        if (debTexCoord.y > 1.0)
		{*/
			#ifdef DEBUG_GBUFFER_WORLDPOS
			WorldPos += 0.01;
            OutColor.rgb = WorldPos - floor(WorldPos);
			#else
            OutColor.rgb = float3(NormalAndDepthDist.a  - floor(NormalAndDepthDist.a));
			#endif
		/*}
    }*/
	
    #endif
}