/*
 * Shadow Cg shader file
 * 
 * This file is part of the "SoftPixel Engine" (Copyright (c) 2008 by Lukas Hermanns)
 * See "SoftPixelEngine.hpp" for license information.
 */

/*

Compilation options:

USE_VSM             -> Enables use of VSMs (variance shadow maps).
USE_RSM				-> Enables use of RMSs (reflective shadow maps).
USE_TEXTURE         -> Enables use of one texture for alpha test.
USE_TEXTURE_MATRIX  -> Enables texture matrix transformations for texture coordinates.

*/

/*
 * ======= Vertex shader: =======
 */

/* === Structures === */

struct SVertexInput
{
    float3 Position	: POSITION;
    #if defined(USE_TEXTURE) || defined(USE_RSM)
    float2 TexCoord	: TEXCOORD0;
    #endif
	#ifdef USE_RSM
    float3 Tangent	: TEXCOORD1;
    float3 Binormal	: TEXCOORD2;
	float3 Normal	: NORMAL;
	#endif
};

struct SVertexOutput
{
    float4 Position : POSITION;
    float3 WorldPos : TEXCOORD0;
    #if defined(USE_TEXTURE) || defined(USE_RSM)
    float2 TexCoord : TEXCOORD1;
    #endif
	#ifdef USE_RSM
	float3 Normal	: TEXCOORD2;
	float3 Binormal	: TEXCOORD3;
	float3 Tangent	: TEXCOORD4;
	#endif
};


/* === Uniforms === */

uniform float4x4 WorldViewProjectionMatrix;
uniform float4x4 WorldMatrix;

#ifdef USE_TEXTURE_MATRIX
uniform float4x4 TextureMatrix;
#endif


/* === Functions === */

SVertexOutput VertexMain(SVertexInput In)
{
    SVertexOutput Out = (SVertexOutput)0;
    
    /* Process vertex transformation for perspective- and global position */
    Out.Position = mul(WorldViewProjectionMatrix, float4(In.Position, 1.0));
    Out.WorldPos = mul(WorldMatrix, float4(In.Position, 1.0)).xyz;

    /* Process texture coordinate */
    #ifdef USE_TEXTURE
    #   ifdef USE_TEXTURE_MATRIX
    Out.TexCoord = (float2)mul(TextureMatrix, float4(In.TexCoord, 0.0, 1.0));
    #   else
    Out.TexCoord = In.TexCoord;
    #   endif
    #endif
	
	/* Process transformation for tangent space */
	#ifdef USE_RSM
	Out.Normal		= mul((float3x3)WorldMatrix, In.Normal);
    Out.Tangent		= mul((float3x3)WorldMatrix, In.Tangent);
    Out.Binormal	= mul((float3x3)WorldMatrix, In.Binormal);
	#endif

    return Out;
}


/*
 * ======= Pixel shader: =======
 */

/* === Structures === */

struct SPixelInput
{
    float3 WorldPos : TEXCOORD0;
    #if defined(USE_TEXTURE) || defined(USE_RSM)
    float2 TexCoord : TEXCOORD1;
    #endif
	#ifdef USE_RSM
	float3 Normal	: TEXCOORD2;
	float3 Binormal	: TEXCOORD3;
	float3 Tangent	: TEXCOORD4;
	#endif
};

struct SPixelOutput
{
    #ifdef USE_VSM
    float4 DepthDist	: COLOR0;
    #else
    float DepthDist		: COLOR0;
    #endif
	#ifdef USE_RSM
	float3 Color		: COLOR1;
	//float3 Normal		: COLOR2;
	#endif
};


/* === Uniforms === */

uniform float3 ViewPosition;    //!< Global camera position.

#if defined(USE_RSM)
uniform sampler2D DiffuseMap	: TEXUNIT0;
//uniform sampler2D NormalMap		: TEXUNIT1;//!WARNING! -> this must be 1, 2 or 3 (dynamically choosen)
#elif defined(USE_TEXTURE)
uniform sampler2D AlphaMap		: TEXUNIT0;
#endif


/* === Functions === */

#ifdef USE_VSM

float2 ComputeMoments(float Depth)
{
    float2 Moments;
    
    // First moment is the depth itself
    Moments.x = Depth;
    
    // Compute partial derivatives of depth
    float dx = ddx(Depth);
    float dy = ddy(Depth);
    
    Moments.y = Depth*Depth + 0.25 * (dx*dx + dy*dy);
    
    return Moments;
}

#endif

SPixelOutput PixelMain(SPixelInput In)
{
    SPixelOutput Out = (SPixelOutput)0;
    
	#if defined(USE_RSM)
	
	/* Sample color- and normal texture */
	float4 Diffuse		= tex2D(DiffuseMap, In.TexCoord);
	//float3 FinalNormal	= tex2D(NormalMap, In.TexCoord).rgb;
	
    /* Perform alpha-test */
    clip(Diffuse.a - 0.5);
	
    #elif defined(USE_TEXTURE)
    
	/* Perform alpha-test */
    clip(tex2D(AlphaMap, In.TexCoord).a - 0.5);
	
    #endif

    /* Compute depth distance */
    float Depth = distance(In.WorldPos, ViewPosition);

    #ifdef USE_VSM

    float2 Moments = ComputeMoments(Depth);

    Out.DepthDist.r = Moments.x;
    Out.DepthDist.a = Moments.y;

    #else

    Out.DepthDist.r = Depth;

    #endif
	
	#ifdef USE_RSM
	
	#	if 0//!!!
    /* Compute normal in tangent-space */
    float3x3 NormalMatrix = float3x3(
        normalize(In.Tangent),
        normalize(In.Binormal),
        normalize(In.Normal)
    );
	
	/* Transform output normal vector as RGB UByte color */
	FinalNormal = FinalNormal * float3(2.0) - float3(1.0);
	FinalNormal = mul(FinalNormal, NormalMatrix);
	//FinalNormal = normalize(reflect(LightDir, FinalNormal));
	FinalNormal = FinalNormal * float3(0.5) + float3(0.5);
	#	endif//!!!
	
	/* Final pixel output */
	Out.Color	= Diffuse.rgb;
	//Out.Normal	= FinalNormal;
	
	#endif
	
    return Out;
}
