/*
 * Deferred GLSL fragment shader body file
 * 
 * This file is part of the "SoftPixel Engine" (Copyright (c) 2008 by Lukas Hermanns)
 * See "SoftPixelEngine.hpp" for license information.
 */

void main()
{
    /* Get texture colors */
	float4 DiffuseAndSpecular = tex2D(DiffuseAndSpecularMap, TexCoord);
    float4 NormalAndDepthDist = tex2D(NormalAndDepthMap, TexCoord);
	
    /* Compute global pixel position (world space) */
	float3 ViewRayNorm = normalize(ViewRay.xyz);
    float3 WorldPos = ViewPosition + ViewRayNorm * float3(NormalAndDepthDist.a);
	
    /* Compute light shading */
	#ifdef HAS_LIGHT_MAP
    float3 StaticDiffuseLight = float3(0.0);
    float3 StaticSpecularLight = float3(0.0);
    #endif
	
    float3 DiffuseLight = AmbientColor;
    float3 SpecularLight = float3(0.0);
	
    for (int i = 0, j = 0; i < LightCount; ++i)
    {
		ComputeLightShading(
			Lights[i], LightsEx[j], WorldPos, NormalAndDepthDist.xyz, 90.0, ViewRayNorm,
			#ifdef HAS_LIGHT_MAP
			StaticDiffuseLight, StaticSpecularLight,
			#endif
			DiffuseLight, SpecularLight
		);
        
        if (Lights[i].Type != LIGHT_POINT)
            ++j;
    }
	
	#ifdef HAS_LIGHT_MAP
	
	/* Mix light shading with light-map illumination */
	float Illumination = tex2D(IlluminationMap, TexCoord).r;
	
	DiffuseLight += (StaticDiffuseLight * float3(Illumination));
	SpecularLight += (StaticSpecularLight * float3(Illumination));
	
	#endif
	
	#ifndef ALLOW_OVERBLENDING
	DiffuseLight = saturate(DiffuseLight);
	SpecularLight = saturate(SpecularLight);
	#endif
	
    DiffuseLight *= DiffuseAndSpecular.rgb;
    SpecularLight *= float3(DiffuseAndSpecular.a);
	
    /* Compute final deferred shaded pixel color */
    OutputColor.rgb	= DiffuseLight + SpecularLight;
    OutputColor.a	= 1.0;
	
	#ifdef BLOOM_FILTER
    OutputSpecular.rgb	= SpecularLight;
    OutputSpecular.a	= 1.0;
    #endif
    
    #ifdef DEBUG_GBUFFER
	
    /*if (debTexCoord.x > 1.0)
    {
        if (debTexCoord.y > 1.0)
            OutputColor.rgb = tex2D(NormalAndDepthMap, TexCoord).rgb * float3(0.5) + float3(0.5);
        else
            OutputColor.rgb = DiffuseAndSpecular.rgb;
    }
    else
    {
        if (debTexCoord.y > 1.0)
		{*/
			#ifdef DEBUG_GBUFFER_WORLDPOS
			WorldPos += 0.01;
            OutputColor.rgb = WorldPos - floor(WorldPos);
			#else
            OutputColor.rgb = float3(NormalAndDepthDist.a  - floor(NormalAndDepthDist.a));
			#endif
		/*}
    }*/
	
    #endif
}