/*
 * Deferred GLSL fragment shader body file
 * 
 * This file is part of the "SoftPixel Engine" (Copyright (c) 2008 by Lukas Hermanns)
 * See "SoftPixelEngine.hpp" for license information.
 */

void main()
{
    float2 TexCoord = TexCoord;
    float2 WinCoord = gl_FragCoord.xy;
	
    #ifdef DEBUG_GBUFFER

    TexCoord *= float2(2.0);
    WinCoord *= float2(2.0);

    float2 debTexCoord = TexCoord;

    if (TexCoord.x > 1.0) TexCoord.x -= 1.0;
    if (TexCoord.y > 1.0) TexCoord.y -= 1.0;

    if (WinCoord.x > ScreenWidth) WinCoord.x -= ScreenWidth;
    if (WinCoord.y > ScreenHeight) WinCoord.y -= ScreenHeight;

    #endif
    
    /* Get texture colors */
    float4 DiffuseAndSpecular = tex2D(DiffuseAndSpecularMap, TexCoord);
    float4 NormalAndDepthDist = tex2D(NormalAndDepthMap, TexCoord);
	
    /* Compute global pixel position */
    #ifdef FLIP_Y_AXIS
    float4 Point = float4(WinCoord.x, ScreenHeight - WinCoord.y, 1.0, 1.0);
    #else
    float4 Point = float4(WinCoord.x, WinCoord.y, 1.0, 1.0);
    #endif
	
	#ifdef _DEB_INVVIEWPROJ_
	
    Frustum2(Point, ScreenWidth, ScreenHeight);
	
    Point.xyz = normalize(Point.xyz) * float3(NormalAndDepthDist.a);
    Point = InvViewProjection * Point;
	
	#else
	
    Frustum(Point, ScreenWidth, ScreenHeight);
	
    Point.xyz = normalize(Point.xyz) * float3(NormalAndDepthDist.a);
    Point = ViewTransform * Point;
	
	#endif

    /* Compute light shading */
	#ifdef HAS_LIGHT_MAP
    float3 StaticDiffuseLight = float3(0.0);
    float3 StaticSpecularLight = float3(0.0);
    #endif
	
    float3 DiffuseLight = AmbientColor;
    float3 SpecularLight = float3(0.0);
	
	float3 ViewDir = normalize(Point.xyz - ViewPosition);
	
    for (int i = 0, j = 0; i < LightCount; ++i)
    {
		ComputeLightShading(
			Lights[i], LightsEx[j], Point.xyz, NormalAndDepthDist.xyz, 90.0, ViewDir,
			#ifdef HAS_LIGHT_MAP
			StaticDiffuseLight, StaticSpecularLight,
			#endif
			DiffuseLight, SpecularLight
		);
        
        if (Lights[i].Type != LIGHT_POINT)
            ++j;
    }
	
	#ifdef HAS_LIGHT_MAP
	
	/* Mix light shading with light-map illumination */
	float Illumination = tex2D(IlluminationMap, TexCoord).r;
	
	DiffuseLight += (StaticDiffuseLight * float3(Illumination));
	SpecularLight += (StaticSpecularLight * float3(Illumination));
	
	#endif
	
	#ifndef ALLOW_OVERBLENDING
	DiffuseLight = saturate(DiffuseLight);
	SpecularLight = saturate(SpecularLight);
	#endif
	
    DiffuseLight *= DiffuseAndSpecular.rgb;
    SpecularLight *= float3(DiffuseAndSpecular.a);
	
    /* Compute final deferred shaded pixel color */
    gl_FragData[0].rgb	= DiffuseLight + SpecularLight;
    gl_FragData[0].a	= 1.0;
	
	#ifdef BLOOM_FILTER
    gl_FragData[1].rgb	= SpecularLight;
    gl_FragData[1].a	= 1.0;
    #endif
    
    #ifdef DEBUG_GBUFFER

    if (debTexCoord.x > 1.0)
    {
        if (debTexCoord.y > 1.0)
            gl_FragData[0].rgb = tex2D(NormalAndDepthMap, TexCoord).rgb * float3(0.5) + float3(0.5);
        else
            gl_FragData[0].rgb = DiffuseAndSpecular.rgb;
    }
    else
    {
        if (debTexCoord.y > 1.0)
		{
			#ifdef DEBUG_GBUFFER_WORLDPOS
            gl_FragData[0].rgb = Point.xyz - floor(Point.xyz);
			#else
            gl_FragData[0].rgb = float3(NormalAndDepthDist.a * 0.025);
			#endif
		}
    }

    #endif
}
