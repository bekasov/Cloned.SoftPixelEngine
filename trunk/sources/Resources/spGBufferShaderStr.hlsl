"/*\n"
" * GBuffer D3D11 shader header file\n"
" * \n"
" * This file is part of the \"SoftPixel Engine\" (Copyright (c) 2008 by Lukas Hermanns)\n"
" * See \"SoftPixelEngine.hpp\" for license information.\n"
" */\n"
"/*\n"
" * HLSL (SM 5) shader core file\n"
" * \n"
" * This file is part of the \"SoftPixel Engine\" (Copyright (c) 2008 by Lukas Hermanns)\n"
" * See \"SoftPixelEngine.hpp\" for license information.\n"
" */\n"
"#define PI      3.14159265359\n"
"#define E      2.71828182846\n"
"#define MUL(m, v)    mul(m, v)\n"
"#define MUL_TRANSPOSED(v, m) mul(v, m)\n"
"#define MUL_NORMAL(n)   (n).xyz = mul((n).xyz, float3x3(Tangent, Binormal, Normal))\n"
"#define CAST(t, v)    ((t)(v))\n"
"#define SAMPLER2D(n, i)   Texture2D n : register(t##i); SamplerState Sampler##n : register(s##i)\n"
"#define SAMPLER2DARRAY(n, i) Texture2DArray n : register(t##i); SamplerState Sampler##n : register(s##i)\n"
"#define SAMPLERCUBEARRAY(n, i) TextureCubeArray n : register(t##i); SamplerState Sampler##n : register(s##i)\n"
"#define mod(a, b)    fmod(a, b)\n"
"#define floatBitsToInt(v)  asint(v)\n"
"#define floatBitsToUInt(v)  asuint(v)\n"
"#define intBitsToFloat(v)  asfloat(v)\n"
"#define uintBitsToFloat(v)  asfloat(v)\n"
"#define tex2D(s, t)    s.Sample(Sampler##s, t)\n"
"#define tex2DArray(s, t)  s.SampleLevel(Sampler##s, t.xyz)\n"
"#define tex2DArrayLod(s, t)  s.SampleLevel(Sampler##s, t.xyz, t.w)\n"
"#define tex2DGrad(s, t, dx, dy) s.SampleGrad(Sampler##s, t, dx, dy)\n"
"#define RWTexture3DUInt   RWTexture3D<uint>\n"
"#define DeclStructuredBuffer(s, n, r) StructuredBuffer<s> n : register(t##r)\n"
"#define DeclBuffer(t, n, r)    Buffer<t> n : register(t##r)\n"
"#define DeclRWStructuredBuffer(s, n, r) RWStructuredBuffer<s> n : register(u##r)\n"
"#define DeclRWBuffer(t, n, r)   RWBuffer<t> n : register(u##r)\n"
"#define DeclConstBuffer(n, r)   cbuffer n : register(b##r)\n"
"inline void InterlockedImageCompareExchange(RWTexture3DUInt Image, int3 Coord, uint Compare, uint Value, out uint Result)\n"
"{\n"
" InterlockedCompareExchange(Image[Coord], Compare, Value, Result);\n"
"}\n"
"/*\n"
"Compilation options:\n"
"USE_TEXTURE_MATRIX  -> Enables texture matrix transformations for texture coordinates.\n"
"NORMAL_MAPPING      -> Enables normal mapping.\n"
"PARALLAX_MAPPING    -> Enables parallax-occlusion mapping (Requires NORMAL_MAPPING to be enabled).\n"
"NORMALMAP_XYZ_H  -> Normal map contains vector data (xyz in RGB) and height-field data (h in Alpha-Channel). When this is defined, no height-map is used for parallax-mapping.\n"
"TESSELLATION        -> Enables height-field tessellation.\n"
"HAS_SPECULAR_MAP    -> Specifies that a specular is used.\n"
"*/\n"
"/*\n"
" * ======= Vertex shader: =======\n"
" */\n"
"struct SVertexInput\n"
"{\n"
"    float3 Position : POSITION;\n"
"    float3 Normal   : NORMAL;\n"
"    float2 TexCoord : TEXCOORD0;\n"
"    #ifdef NORMAL_MAPPING\n"
"    float3 Tangent  : TEXCOORD1;\n"
"    float3 Binormal : TEXCOORD2;\n"
"    #endif\n"
"};\n"
"struct SVertexOutput\n"
"{\n"
"    float4 Position                 : SV_Position;\n"
"    float2 TexCoord                 : TEXCOORD0;\n"
"    float3 WorldPos                 : TEXCOORD1;\n"
"    float3 Normal                   : TEXCOORD2;\n"
"    #ifdef NORMAL_MAPPING\n"
"    float3 Tangent                  : TEXCOORD3;\n"
"    float3 Binormal                 : TEXCOORD4;\n"
"    #   ifdef PARALLAX_MAPPING\n"
"    float4 ViewVertexDirAndDepth    : TEXCOORD5;\n"
"    #   endif\n"
"    #endif\n"
"};\n"
"cbuffer BufferMain : register(b0)\n"
"{\n"
"    float4x4 WorldViewProjectionMatrix;\n"
"    float4x4 WorldMatrix;\n"
"    #ifdef USE_TEXTURE_MATRIX\n"
"    float4x4 TextureMatrix;\n"
"    #endif\n"
"    float3 ViewPosition;    //!< Global camera position.\n"
"};\n"
"SVertexOutput VertexMain(SVertexInput In)\n"
"{\n"
"    SVertexOutput Out = (SVertexOutput)0;\n"
"    \n"
"    /* Process vertex transformation for position and normal */\n"
"    float3x3 NormalMatrix = (float3x3)WorldMatrix;\n"
"    Out.Position    = mul(WorldViewProjectionMatrix, float4(In.Position, 1.0));\n"
"    Out.WorldPos    = mul(WorldMatrix, float4(In.Position, 1.0)).xyz;\n"
"    Out.Normal      = mul(NormalMatrix, In.Normal);\n"
"    #ifdef NORMAL_MAPPING\n"
"    \n"
"    /* Process transformation for tangent space */\n"
"    Out.Tangent     = mul(NormalMatrix, In.Tangent);\n"
"    Out.Binormal    = mul(NormalMatrix, In.Binormal);\n"
"    #   ifdef PARALLAX_MAPPING\n"
"    NormalMatrix = float3x3(\n"
"        normalize(Out.Tangent),\n"
"        normalize(Out.Binormal),\n"
"        normalize(Out.Normal)\n"
"    );\n"
"    Out.ViewVertexDirAndDepth.xyz   = ViewPosition - Out.WorldPos.xyz;\n"
"    Out.ViewVertexDirAndDepth.xyz   = mul(NormalMatrix, Out.ViewVertexDirAndDepth.xyz);\n"
"    Out.ViewVertexDirAndDepth.y     = -Out.ViewVertexDirAndDepth.y;\n"
"    Out.ViewVertexDirAndDepth.w     = Out.Position.z;\n"
"    #   endif\n"
"    #endif\n"
"    #ifdef USE_TEXTURE_MATRIX\n"
"    Out.TexCoord = (float2)mul(TextureMatrix, float4(In.TexCoord, 0.0, 1.0));\n"
"    #else\n"
"    Out.TexCoord = In.TexCoord;\n"
"    #endif\n"
"    \n"
"    return Out;\n"
"}\n"
"/*\n"
" * ======= Pixel shader: =======\n"
" */\n"
"struct SPixelOutput\n"
"{\n"
"    float4 DiffuseAndSpecular   : SV_Target0;\n"
"    float4 NormalAndDepth       : SV_Target1;\n"
"};\n"
"SAMPLER2D(DiffuseMap, 0);\n"
"#ifdef HAS_SPECULAR_MAP\n"
"SAMPLER2D(SpecularMap, 1);\n"
"#endif\n"
"#ifdef NORMAL_MAPPING\n"
"#   ifdef HAS_SPECULAR_MAP\n"
"SAMPLER2D(NormalMap, 2);\n"
"#       if defined(PARALLAX_MAPPING) && !defined(NORMALMAP_XYZ_H)\n"
"SAMPLER2D(HeightMap, 3);\n"
"#       endif\n"
"#   else\n"
"SAMPLER2D(NormalMap, 1);\n"
"#       if defined(PARALLAX_MAPPING) && !defined(NORMALMAP_XYZ_H)\n"
"SAMPLER2D(HeightMap, 2);\n"
"#       endif\n"
"#   endif\n"
"#endif\n"
"cbuffer BufferRelief : register(b1)\n"
"{\n"
"    float SpecularFactor    : packoffset(c0.x);\n"
"    float HeightMapScale    : packoffset(c0.y);\n"
"    float ParallaxViewRange : packoffset(c0.z);\n"
"    int EnablePOM           : packoffset(c1.x);\n"
"    int MinSamplesPOM       : packoffset(c1.y);\n"
"    int MaxSamplesPOM       : packoffset(c1.z);\n"
"};\n"
"SPixelOutput PixelMain(SVertexOutput In)\n"
"{\n"
"    SPixelOutput Out = (SPixelOutput)0;\n"
"    \n"
"    float4 DiffuseAndSpecular = (float4)0.0;\n"
"    float4 NormalAndDepth = (float4)0.0;\n"
"    float2 TexCoord                 = In.TexCoord;\n"
"    float3 WorldPos                 = In.WorldPos;\n"
"    float3 Normal                   = In.Normal;\n"
"    #ifdef NORMAL_MAPPING\n"
"    \n"
"    float3 Tangent                  = In.Tangent;\n"
"    float3 Binormal                 = In.Binormal;\n"
"    #   ifdef PARALLAX_MAPPING\n"
"    float4 ViewVertexDirAndDepth    = In.ViewVertexDirAndDepth;\n"
"    #   endif\n"
"    #endif\n"
"/*\n"
" * GBuffer pixel shader main file\n"
" * \n"
" * This file is part of the \"SoftPixel Engine\" (Copyright (c) 2008 by Lukas Hermanns)\n"
" * See \"SoftPixelEngine.hpp\" for license information.\n"
" */\n"
"#ifndef NORMAL_MAPPING\n"
"DiffuseAndSpecular = tex2D(DiffuseMap, TexCoord);\n"
"#   ifdef HAS_SPECULAR_MAP\n"
"DiffuseAndSpecular.a = tex2D(SpecularMap, TexCoord).r * SpecularFactor;\n"
"#   endif\n"
"NormalAndDepth.xyz = Normal;\n"
"#else\n"
"#   ifdef PARALLAX_MAPPING\n"
"if (!EnablePOM)\n"
"{\n"
"#   endif\n"
" DiffuseAndSpecular = tex2D(DiffuseMap, TexCoord);\n"
" clip(DiffuseAndSpecular.a - 0.5);\n"
" NormalAndDepth.xyz = tex2D(NormalMap, TexCoord).rgb;\n"
" #ifdef HAS_SPECULAR_MAP\n"
" DiffuseAndSpecular.a = tex2D(SpecularMap, TexCoord).r * SpecularFactor;\n"
" #endif\n"
"#   ifdef PARALLAX_MAPPING\n"
"}\n"
"else\n"
"{\n"
" float ParallaxLimit = (length(ViewVertexDirAndDepth.xy) / ViewVertexDirAndDepth.z) * HeightMapScale;\n"
" float2 Offset       = normalize(-ViewVertexDirAndDepth.xy) * ParallaxLimit;\n"
" float Interpolation = saturate(ParallaxViewRange / ViewVertexDirAndDepth.w);\n"
" int NumSamples      = int(lerp(float(MinSamplesPOM), float(MaxSamplesPOM), Interpolation));\n"
" float StepSize      = 1.0 / float(NumSamples);\n"
" float2 dx           = ddx(TexCoord);\n"
" float2 dy           = ddy(TexCoord);\n"
" float2 OffsetStep   = Offset * StepSize;\n"
" float2 CurOffset    = CAST(float2, 0.0);\n"
" float2 PrevOffset   = CAST(float2, 0.0);\n"
" float CurSample     = 0.0;\n"
" float PrevSample    = 0.0;\n"
" float StepHeight    = 1.0;\n"
" int SampleIndex     = 0;\n"
" while (SampleIndex < NumSamples)\n"
" {\n"
"  #ifdef NORMALMAP_XYZ_H\n"
"  CurSample = tex2DGrad(NormalMap, TexCoord + CurOffset, dx, dy).a;\n"
"  #else\n"
"  CurSample = tex2DGrad(HeightMap, TexCoord + CurOffset, dx, dy).r;\n"
"  #endif\n"
"  if (CurSample > StepHeight)\n"
"  {\n"
"   float Ua = (PrevSample - (StepHeight + StepSize)) / (StepSize + (CurSample - PrevSample));\n"
"   CurOffset = PrevOffset + OffsetStep * Ua;\n"
"   break;\n"
"  }\n"
"  else\n"
"  {\n"
"   ++SampleIndex;\n"
"   StepHeight -= StepSize;\n"
"   PrevOffset = CurOffset;\n"
"   CurOffset += OffsetStep;\n"
"   PrevSample = CurSample;\n"
"  }\n"
" }\n"
" DiffuseAndSpecular = tex2DGrad(DiffuseMap, TexCoord + CurOffset, dx, dy);\n"
" NormalAndDepth.xyz = tex2DGrad(NormalMap, TexCoord + CurOffset, dx, dy).rgb;\n"
" #ifdef HAS_SPECULAR_MAP\n"
" DiffuseAndSpecular.a = tex2DGrad(SpecularMap, TexCoord + CurOffset, dx, dy).r * SpecularFactor;\n"
" #endif\n"
"}\n"
"#   endif // /PARALLAX_MAPPING\n"
"NormalAndDepth.xyz = NormalAndDepth.xyz * 2.0 - 1.0;\n"
"MUL_NORMAL(NormalAndDepth.xyz);\n"
"#endif // /NORMAL_MAPPING\n"
"#ifndef HAS_SPECULAR_MAP\n"
"DiffuseAndSpecular.a = SpecularFactor;\n"
"#endif\n"
"NormalAndDepth.a = distance(ViewPosition, WorldPos);\n"
"    Out.DiffuseAndSpecular = DiffuseAndSpecular;\n"
"    Out.NormalAndDepth = NormalAndDepth;\n"
"    return Out;\n"
"}\n"
