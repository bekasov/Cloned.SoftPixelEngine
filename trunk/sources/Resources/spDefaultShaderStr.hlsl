"/*\n"
" * D3D11 default shader file\n"
" * \n"
" * This file is part of the \"SoftPixel Engine\" (Copyright (c) 2008 by Lukas Hermanns)\n"
" * See \"SoftPixelEngine.hpp\" for license information.\n"
" */\n"
"/*\n"
" * Global members\n"
" */\n"
"Texture2D Texture2D0 : register(t0);\n"
"Texture2D Texture2D1 : register(t1);\n"
"Texture2D Texture2D2 : register(t2);\n"
"Texture2D Texture2D3 : register(t3);\n"
"SamplerState SamplerLinear0 : register(s0);\n"
"SamplerState SamplerLinear1 : register(s1);\n"
"SamplerState SamplerLinear2 : register(s2);\n"
"SamplerState SamplerLinear3 : register(s3);\n"
"/*\n"
" * Constant buffer structures\n"
" */\n"
"struct SLight\n"
"{\n"
" int Model;       // Light model (Directionl, Point, Spot)\n"
" int Enabled;      // Enabled/ disabled\n"
" int2 Pad0;\n"
" float4 Position;     // Position for Point- and Spot light and Direction for Directional light\n"
" float4 Diffuse, Ambient, Specular; // Light colors\n"
" float4 SpotDir;      // Spot light direction\n"
"    float3 Attn;               // Attunation values\n"
" int Pad1;\n"
" float Theta, Phi, Falloff, Range; // Spot light attributes\n"
"};\n"
"struct SMaterial\n"
"{\n"
" float4 Diffuse, Ambient, Specular, Emission; // Material colors\n"
" int Shading;         // Shading (flat, gouraud, phong, perpixel)\n"
" int LightingEnabled;       // Global lighting enabled/ disabled\n"
" int FogEnabled;         // Global fog enabled/ disabled\n"
" float Shininess;        // Specular shininess\n"
" int AlphaMethod;        // Alpha test function\n"
" float AlphaReference;       // Alpha test reference value\n"
" int2 Pad0;\n"
"};\n"
"struct STextureLayer\n"
"{\n"
" int3 MapGenType; // Texture coordinate generation\n"
" int EnvType;  // Texture environment\n"
" float4x4 Matrix; // Texture coordiante transformation\n"
"};\n"
"struct SClipPlane\n"
"{\n"
" int Enabled; // Enabled/ disabled\n"
" int3 Pad0;\n"
" float3 Normal; // Plane normal vector\n"
" float Distance; // Plane distance to the origin\n"
"};\n"
"struct SFogStates\n"
"{\n"
" int Mode;   // Fog mode (Plane, Thick etc.)\n"
" float Density;  // Density/ thickness\n"
" float Near, Far; // Near/ far planes\n"
" float4 Color;  // Fog color\n"
"};\n"
"/*\n"
" * Constant buffers\n"
" */\n"
"cbuffer ConstantBufferLights : register(b0)\n"
"{\n"
" SLight Lights[8]; // Light sources\n"
"};\n"
"cbuffer ConstantBufferObject : register(b1)\n"
"{\n"
" float4x4 WorldMatrix, ViewMatrix, ProjectionMatrix; // Matrices\n"
" SMaterial Material;         // Material attributes\n"
"};\n"
"cbuffer ConstantBufferSurface : register(b2)\n"
"{\n"
" uint TextureLayersEnabled;  // Bit mask for enabled texture layers\n"
" int3 Pad0;\n"
" STextureLayer TextureLayers[4]; // Texture surfaces\n"
"};\n"
"cbuffer ConstantBufferDriverSettings : register(b3)\n"
"{\n"
" SClipPlane Planes[8]; // Clipping planes\n"
" SFogStates Fog;   // Fog effect states\n"
"};\n"
"/*\n"
" * Macros\n"
" */\n"
"#define EPSILON                 0.001\n"
"#define MAPGEN_DISABLE    0\n"
"#define MAPGEN_OBJECT_LINEAR 1\n"
"#define MAPGEN_EYE_LINEAR  2\n"
"#define MAPGEN_SPHERE_MAP  3\n"
"#define MAPGEN_NORMAL_MAP  4\n"
"#define MAPGEN_REFLECTION_MAP 5\n"
"#define LIGHT_DIRECTIONAL  0\n"
"#define LIGHT_POINT    1\n"
"#define LIGHT_SPOT    2\n"
"#define SHADING_FLAT   0\n"
"#define SHADING_GOURAUD   1\n"
"#define SHADING_PHONG   2\n"
"#define SHADING_PERPIXEL  3\n"
"#define TEXENV_MODULATE   0\n"
"#define TEXENV_REPLACE   1\n"
"#define TEXENV_ADD    2\n"
"#define TEXENV_ADDSIGNED  3\n"
"#define TEXENV_SUBTRACT   4\n"
"#define TEXENV_INTERPOLATE  5\n"
"#define TEXENV_DOT3    6\n"
"#define CMPSIZE_NEVER   0\n"
"#define CMPSIZE_EQUAL   1\n"
"#define CMPSIZE_NOTEQUAL  2\n"
"#define CMPSIZE_LESS   3\n"
"#define CMPSIZE_LESSEQUAL  4\n"
"#define CMPSIZE_GREATER   5\n"
"#define CMPSIZE_GREATEREQUAL 6\n"
"#define CMPSIZE_ALWAYS   7\n"
"#define FOG_STATIC_PALE   0\n"
"#define FOG_STATIC_THICK  1\n"
"#define FOG_VOLUMETRIC   2\n"
"#define TEXLAYER_ENABLED(i) (((TextureLayersEnabled >> i) & 0x00000001) != 0)\n"
"/*\n"
" * Structures\n"
" */\n"
"struct VertexInput\n"
"{\n"
" float3 Position  : POSITION;\n"
" float3 Normal  : NORMAL;\n"
" float4 Color  : COLOR;\n"
" float2 TexCoord0 : TEXCOORD0;\n"
" float2 TexCoord1 : TEXCOORD1;\n"
" float2 TexCoord2 : TEXCOORD2;\n"
" float2 TexCoord3 : TEXCOORD3;\n"
"};\n"
"struct VertexPixelExchange\n"
"{\n"
" float4 Position  : SV_Position;\n"
" float3 Normal  : NORMAL;\n"
" float4 Diffuse  : COLOR0;\n"
" float4 Ambient  : COLOR1;\n"
" float2 TexCoord0 : TEXCOORD0;\n"
" float2 TexCoord1 : TEXCOORD1;\n"
" float2 TexCoord2 : TEXCOORD2;\n"
" float2 TexCoord3 : TEXCOORD3;\n"
" float4 WorldPos  : POSITION1;\n"
" float4 WorldViewPos : POSITION2;\n"
"};\n"
"/*\n"
" * Functions\n"
" */\n"
"void LightCalculation(int i, float3 Normal, float3 Position, inout float4 ColorOut)\n"
"{\n"
" float Intensity = 1.0;\n"
" switch (Lights[i].Model)\n"
" {\n"
"  case LIGHT_DIRECTIONAL:\n"
"   Intensity = saturate(dot(Normal, Lights[i].Position.xyz));\n"
"   break;\n"
"  case LIGHT_POINT:\n"
"   Intensity = saturate(dot(Normal, normalize(Lights[i].Position.xyz - Position)));\n"
"   break;\n"
"  case LIGHT_SPOT:\n"
"   break;\n"
" }\n"
" if (Lights[i].Model != LIGHT_DIRECTIONAL)\n"
" {\n"
"  const float Distance = distance(Lights[i].Position.xyz, Position);\n"
"  float Attn = 1.0 / ( Lights[i].Attn.x + Lights[i].Attn.y*Distance + Lights[i].Attn.z*Distance*Distance );\n"
"        Intensity *= Attn;\n"
" }\n"
" ColorOut += Lights[i].Diffuse * Intensity;\n"
"}\n"
"void FogCalculation(float Depth, inout float4 Color)\n"
"{\n"
" float Factor = 0.0;\n"
" switch (Fog.Mode)\n"
" {\n"
"  case FOG_STATIC_PALE:\n"
"   Factor = exp(-Fog.Density * Depth); break;\n"
"  case FOG_STATIC_THICK:\n"
"  {\n"
"   float TempFactor = Fog.Density * Depth;\n"
"   Factor = exp(-TempFactor * TempFactor);\n"
"  }\n"
"  break;\n"
" }\n"
" clamp(Factor, 0.0, 1.0);\n"
" Color.xyz = Fog.Color.xyz * (1.0 - Factor) + Color.xyz * Factor;\n"
"}\n"
"float ClippingPlane(int i, float4 Position)\n"
"{\n"
" return dot(Position.xyz, normalize(Planes[i].Normal)) + Planes[i].Distance;\n"
"}\n"
"void TexCoordGeneration(int MapGenType, float Pos, float WorldViewPos, float TransNormal, float TexCoordIn, inout float TexCoordOut)\n"
"{\n"
" switch (MapGenType)\n"
" {\n"
"  case MAPGEN_DISABLE:\n"
"   TexCoordOut = TexCoordIn; break;\n"
"  case MAPGEN_OBJECT_LINEAR:\n"
"   TexCoordOut = Pos; break;\n"
"  case MAPGEN_EYE_LINEAR:\n"
"   TexCoordOut = WorldViewPos; break;\n"
"  case MAPGEN_SPHERE_MAP:\n"
"   TexCoordOut = TransNormal*0.5 + 0.5; break;\n"
"  case MAPGEN_NORMAL_MAP:\n"
"   break; //!TODO!\n"
"  case MAPGEN_REFLECTION_MAP:\n"
"   break; //!TODO!\n"
" }\n"
"}\n"
"void TextureMapping(int i, Texture2D Tex, SamplerState Sampler, float2 TexCoord, inout float4 ColorOut)\n"
"{\n"
" const float4 TexColor = Tex.Sample(Sampler, TexCoord);\n"
" switch (TextureLayers[i].EnvType)\n"
" {\n"
"  case TEXENV_MODULATE:\n"
"   ColorOut *= TexColor; break;\n"
"  case TEXENV_REPLACE:\n"
"   ColorOut = TexColor; break;\n"
"  case TEXENV_ADD:\n"
"   ColorOut += TexColor; break;\n"
"  case TEXENV_ADDSIGNED:\n"
"   ColorOut += TexColor - float4(0.5, 0.5, 0.5, 1.0); break;\n"
"  case TEXENV_SUBTRACT:\n"
"   ColorOut -= TexColor; break;\n"
"  case TEXENV_INTERPOLATE:\n"
"   break; //!TODO!\n"
"  case TEXENV_DOT3:\n"
"   ColorOut.r = (ColorOut.r - 0.5)*(TexColor.r - 0.5);\n"
"   ColorOut.g = (ColorOut.g - 0.5)*(TexColor.g - 0.5);\n"
"   ColorOut.b = (ColorOut.b - 0.5)*(TexColor.b - 0.5);\n"
"   break;\n"
" }\n"
"}\n"
"/*\n"
" * ======= Vertex Shader =======\n"
" */\n"
"VertexPixelExchange VertexMain(VertexInput In)\n"
"{\n"
" #define mcrTexCoordGeneration(t, c)                       \\\n"
"  TexCoordGeneration(TextureLayers[t].MapGenType.x, In.Position.x, Out.WorldViewPos.x, TransNormal.x, In.c.x, Out.c.x); \\\n"
"  TexCoordGeneration(TextureLayers[t].MapGenType.y, In.Position.y, Out.WorldViewPos.y, TransNormal.y, In.c.y, Out.c.y);\n"
" #define mcrTexCoordTransform(i, t) \\\n"
"  Out.t = mul(float4(Out.t.x, Out.t.y, 0.0, 1.0), TextureLayers[i].Matrix).xy;\n"
" VertexPixelExchange Out = (VertexPixelExchange)0;\n"
" Out.WorldPos  = mul(WorldMatrix, float4(In.Position, 1.0));\n"
" Out.WorldViewPos = mul(ViewMatrix, Out.WorldPos);\n"
" Out.Position  = mul(ProjectionMatrix, Out.WorldViewPos);\n"
" float3 TransNormal = mul((float3x3)WorldMatrix, In.Normal);\n"
" TransNormal   = mul((float3x3)ViewMatrix, TransNormal);\n"
" TransNormal   = normalize(TransNormal);\n"
" Out.Normal   = TransNormal;\n"
" Out.Diffuse = In.Color * Material.Diffuse;\n"
" Out.Ambient = Material.Ambient;\n"
" if (Material.LightingEnabled && Material.Shading < SHADING_PHONG)\n"
" {\n"
"  float4 LightColor = Out.Ambient;\n"
"  for (int i = 0; i < 8; ++i)\n"
"  {\n"
"   if (Lights[i].Enabled)\n"
"    LightCalculation(i, Out.Normal, Out.WorldViewPos.xyz, LightColor);\n"
"  }\n"
"  LightColor = saturate(LightColor);\n"
"  Out.Diffuse.rgb *= LightColor.rgb;\n"
"  Out.Diffuse = saturate(Out.Diffuse);\n"
" }\n"
" if (TEXLAYER_ENABLED(0))\n"
" {\n"
"  mcrTexCoordGeneration(0, TexCoord0);\n"
"  mcrTexCoordTransform(0, TexCoord0);\n"
" }\n"
" if (TEXLAYER_ENABLED(1))\n"
" {\n"
"  mcrTexCoordGeneration(1, TexCoord1);\n"
"  mcrTexCoordTransform(1, TexCoord1);\n"
" }\n"
" if (TEXLAYER_ENABLED(2))\n"
" {\n"
"  mcrTexCoordGeneration(2, TexCoord2);\n"
"  mcrTexCoordTransform(2, TexCoord2);\n"
" }\n"
" if (TEXLAYER_ENABLED(3))\n"
" {\n"
"  mcrTexCoordGeneration(3, TexCoord3);\n"
"  mcrTexCoordTransform(3, TexCoord3);\n"
" }\n"
" return Out;\n"
" #undef mcrTexCoordGeneration\n"
" #undef mcrTexCoordTransform\n"
"}\n"
"/*\n"
" * ======= Pixel Shader =======\n"
" */\n"
"float4 PixelMain(VertexPixelExchange In) : SV_Target\n"
"{\n"
" float4 Out = (float4)0;\n"
" float4 TexColor  = 1.0;\n"
" float4 LightColor = 1.0;\n"
" if (Material.LightingEnabled && Material.Shading >= SHADING_PHONG)\n"
" {\n"
"  LightColor = In.Ambient;\n"
"  float3 Normal = normalize(In.Normal);\n"
"  for (int i = 0; i < 8; ++i)\n"
"  {\n"
"   if (Lights[i].Enabled)\n"
"    LightCalculation(i, Normal, In.WorldViewPos.xyz, LightColor);\n"
"  }\n"
"  LightColor = saturate(LightColor);\n"
" }\n"
" if (TEXLAYER_ENABLED(0))\n"
"  TextureMapping(0, Texture2D0, SamplerLinear0, In.TexCoord0, TexColor);\n"
" if (TEXLAYER_ENABLED(1))\n"
"  TextureMapping(1, Texture2D1, SamplerLinear1, In.TexCoord1, TexColor);\n"
" if (TEXLAYER_ENABLED(2))\n"
"  TextureMapping(2, Texture2D2, SamplerLinear2, In.TexCoord2, TexColor);\n"
" if (TEXLAYER_ENABLED(3))\n"
"  TextureMapping(3, Texture2D3, SamplerLinear3, In.TexCoord3, TexColor);\n"
" Out = In.Diffuse * TexColor * float4(LightColor.rgb, 1.0);\n"
" if (Material.FogEnabled)\n"
"  FogCalculation(In.WorldViewPos.z, Out);\n"
" switch (Material.AlphaMethod)\n"
" {\n"
"  case CMPSIZE_ALWAYS:\n"
"   break;\n"
"  case CMPSIZE_GREATEREQUAL:\n"
"            clip(Out.a - Material.AlphaReference);\n"
"   break;\n"
"  case CMPSIZE_GREATER:\n"
"            clip(Out.a - Material.AlphaReference - EPSILON);\n"
"   break;\n"
"  case CMPSIZE_LESSEQUAL:\n"
"            clip(Material.AlphaReference - Out.a);\n"
"   break;\n"
"  case CMPSIZE_LESS:\n"
"            clip(Material.AlphaReference - Out.a - EPSILON);\n"
"   break;\n"
"  case CMPSIZE_NOTEQUAL:\n"
"            clip(abs(Out.a - Material.AlphaReference) - EPSILON);\n"
"   break;\n"
"  case CMPSIZE_EQUAL:\n"
"            clip(-abs(Out.a - Material.AlphaReference) + EPSILON);\n"
"   break;\n"
"  case CMPSIZE_NEVER:\n"
"   clip(-1.0);\n"
"            break;\n"
"  default:\n"
"   break;\n"
" }\n"
" for (int i = 0; i < 8; ++i)\n"
" {\n"
"  if (Planes[i].Enabled)\n"
"   clip(ClippingPlane(i, In.WorldPos));\n"
" }\n"
" return Out;\n"
"}\n"
