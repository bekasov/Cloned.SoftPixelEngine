"/*\n"
" * Deferred GLSL fragment shader file\n"
" * \n"
" * This file is part of the \"SoftPixel Engine\" (Copyright (c) 2008 by Lukas Hermanns)\n"
" * See \"SoftPixelEngine.hpp\" for license information.\n"
" */\n"
"#version 140\n"
"/*\n"
" * GLSL shader core file\n"
" * \n"
" * This file is part of the \"SoftPixel Engine\" (Copyright (c) 2008 by Lukas Hermanns)\n"
" * See \"SoftPixelEngine.hpp\" for license information.\n"
" */\n"
"#define PI   3.14159265359\n"
"#define E   2.71828182846\n"
"#define float2  vec2\n"
"#define float3  vec3\n"
"#define float4  vec4\n"
"#define double2  dvec2\n"
"#define double3  dvec3\n"
"#define double4  dvec4\n"
"#define bool2  bvec2\n"
"#define bool3  bvec3\n"
"#define bool4  bvec4\n"
"#define int2  ivec2\n"
"#define int3  ivec3\n"
"#define int4  ivec4\n"
"#define uint2  uvec2\n"
"#define uint3  uvec3\n"
"#define uint4  uvec4\n"
"#define half  float\n"
"#define half2  vec2\n"
"#define half3  vec3\n"
"#define half4  vec4\n"
"#define float2x2 mat2\n"
"#define float3x3 mat3\n"
"#define float4x4 mat4\n"
"#define float2x3 mat2x3\n"
"#define float2x4 mat2x4\n"
"#define float3x2 mat3x2\n"
"#define float3x4 mat3x4\n"
"#define float4x2 mat4x2\n"
"#define float4x3 mat4x3\n"
"#define double2x2 dmat2\n"
"#define double3x3 dmat3\n"
"#define double4x4 dmat4\n"
"#define double2x3 dmat2x3\n"
"#define double2x4 dmat2x4\n"
"#define double3x2 dmat3x2\n"
"#define double3x4 dmat3x4\n"
"#define double4x2 dmat4x2\n"
"#define double4x3 dmat4x3\n"
"#define bool2x2  bmat2\n"
"#define bool3x3  bmat3\n"
"#define bool4x4  bmat4\n"
"#define bool2x3  bmat2x3\n"
"#define bool2x4  bmat2x4\n"
"#define bool3x2  bmat3x2\n"
"#define bool3x4  bmat3x4\n"
"#define bool4x2  bmat4x2\n"
"#define bool4x3  bmat4x3\n"
"#define int2x2  imat2\n"
"#define int3x3  imat3\n"
"#define int4x4  imat4\n"
"#define int2x3  imat2x3\n"
"#define int2x4  imat2x4\n"
"#define int3x2  imat3x2\n"
"#define int3x4  imat3x4\n"
"#define int4x2  imat4x2\n"
"#define int4x3  imat4x3\n"
"#define uint2x2  umat2\n"
"#define uint3x3  umat3\n"
"#define uint4x4  umat4\n"
"#define uint2x3  umat2x3\n"
"#define uint2x4  umat2x4\n"
"#define uint3x2  umat3x2\n"
"#define uint3x4  umat3x4\n"
"#define uint4x2  umat4x2\n"
"#define uint4x3  umat4x3\n"
"#define MUL(m, v)    (m) * (v)\n"
"#define MUL_TRANSPOSED(m, v) transpose(m) * (v)\n"
"#define MUL_NORMAL(n)   (n).xyz = float3x3(Tangent, Binormal, Normal) * (n).xyz\n"
"#define CAST(t, v)    (t(v))\n"
"#define SAMPLER2D(n, i)   uniform sampler2D n\n"
"#define saturate(v)    clamp(v, 0.0, 1.0)\n"
"#define clip(v)     if (v < 0.0) { discard; }\n"
"#define frac(v)     fract(v)\n"
"#define lerp(x, y, s)   mix(x, y, s)\n"
"#define tex2D     texture2D\n"
"#define tex2Dgrad    texture2DGradARB\n"
"#define tex2DArrayLod(s, t)  texture2DArrayLod(s, (t).xyz, (t).w)\n"
"#define tex2DArray(s, t)  texture2DArray(s, t)\n"
"#define tex2DGrad(s, t, dx, dy) texture2DGradARB(s, t, dx, dy)\n"
"#define ddx(v)     dFdx(v)\n"
"#define ddy(v)     dFdy(v)\n"
"#define DeclStructuredBuffer(s, n, r)      \\\n"
" layout(std430, binding = r) readonly buffer Buffer##n \\\n"
" {              \\\n"
"  s n[];            \\\n"
" }\n"
"#define DeclBuffer(t, n, r)         \\\n"
" layout(std430, binding = r) readonly buffer Buffer##n \\\n"
" {              \\\n"
"  t n[];            \\\n"
" }\n"
"#define DeclRWStructuredBuffer(s, n, r)    \\\n"
" layout(std430, binding = r) buffer Buffer##n \\\n"
" {            \\\n"
"  s n[];          \\\n"
" }\n"
"#define DeclRWBuffer(t, n, r)      \\\n"
" layout(std430, binding = r) buffer Buffer##n \\\n"
" {            \\\n"
"  t n[];          \\\n"
" }\n"
"#define DeclConstBuffer(n, r)       layout(std140, binding = r) uniform n\n"
"#define RWTexture3DUInt         layout(r32ui) coherent volatile uimage3D\n"
"#define groupshared          shared\n"
"#define floatBitsToUInt(v)        floatBitsToUint(v)\n"
"#define InterlockedAdd(d, v, o)       o = atomicAdd(d, v)\n"
"#define InterlockedAnd(d, v, o)       o = atomicAnd(d, v)\n"
"#define InterlockedOr(d, v, o)       o = atomicOr(d, v)\n"
"#define InterlockedXor(d, v, o)       o = atomicXor(d, v)\n"
"#define InterlockedMin(d, v, o)       o = atomicMin(d, v)\n"
"#define InterlockedMax(d, v, o)       o = atomicMax(d, v)\n"
"#define InterlockedCompareExchange(d, v, o)    o = atomicCompSwap(d, v)\n"
"#define InterlockedExchange(d, v, o)     o = atomicExchange(d, v)\n"
"#define GroupMemoryBarrier        groupMemoryBarrier\n"
"#define InterlockedImageCompareExchange(i, p, c, v, o) o = imageAtomicCompSwap(i, p, c, v)\n"
"/*\n"
" * Deferred shader header file\n"
" * \n"
" * This file is part of the \"SoftPixel Engine\" (Copyright (c) 2008 by Lukas Hermanns)\n"
" * See \"SoftPixelEngine.hpp\" for license information.\n"
" */\n"
"#ifndef MAX_LIGHTS\n"
"# define MAX_LIGHTS            35\n"
"#endif\n"
"#ifndef MAX_EX_LIGHTS\n"
"# define MAX_EX_LIGHTS         15\n"
"#endif\n"
"#ifndef NUM_JITTERD_OFFSETS\n"
"# define NUM_JITTERD_OFFSETS  20\n"
"#endif\n"
"#define LIGHT_DIRECTIONAL        0\n"
"#define LIGHT_POINT              1\n"
"#define LIGHT_SPOT               2\n"
"#define AMBIENT_LIGHT_FACTOR     0.0/*0.1*/ //!< Should be in the range [0.0 .. 1.0].\n"
"#define LIGHT_CUTOFF    0.01\n"
"#define MIN_VARIANCE             1.0\n"
"#define EOL       0xFFFFFFFF //!< Id for 'end-of-linked-list'\n"
"#define VPL_SINGULARITY_CLAMP  0.1\n"
"#define VPL_COUNT     100\n"
"#define SHININESS_FACTOR   90.0\n"
"#ifdef TILED_SHADING\n"
"# define TILED_LIGHT_GRID_WIDTH 32\n"
"# define TILED_LIGHT_GRID_HEIGHT 32\n"
"#endif\n"
"struct SLightNode\n"
"{\n"
" uint LightID; //!< SLight index.\n"
" uint Next;  //!< Next SLightNode index. 'EOL' if end of linked list.\n"
"};\n"
"struct SLight\n"
"{\n"
"    float4 PositionAndInvRadius;    //!< Position (xyz), Inverse Radius (w).\n"
"    float3 Color;                   //!< Light color (used for diffuse and specular).\n"
" float Pad0;\n"
"    int Type;                       //!< 0 -> Directional light, 1 -> Point light, 2 -> Spot light.\n"
"    int ShadowIndex;                //!< Shadow map layer index. -1 -> no shadow map.\n"
" int UsedForLightmaps;      //!< Specifies whether this light is used for lightmaps or not.\n"
" int ExID;      //!< Index to the associated 'SLightEx' element.\n"
"};\n"
"struct SLightEx\n"
"{\n"
"    float4x4 ViewProjection;    //!< Spot-/ directional view-projection matrix.\n"
" float4x4 InvViewProjection; //!< Inverse view-projection matrix.\n"
"    float3 Direction;           //!< Spot-/ directional light direction.\n"
" float Pad0;\n"
"    float SpotTheta;   //!< First spot cone angle (in radian).\n"
"    float SpotPhiMinusTheta; //!< Second minus first spot cone angle (in radian).\n"
" float Pad1[2];\n"
"};\n"
"#ifdef GLOBAL_ILLUMINATION\n"
"struct SVPL\n"
"{\n"
" float3 WorldPos;\n"
" float3 Normal;\n"
" float3 Color;\n"
"};\n"
"#endif\n"
"/*\n"
"Compilation options:\n"
"MAX_LIGHTS    -> Maximal count of light sources.\n"
"MAX_EX_LIGHTS   -> Maximal count of extended light sources (e.g. spot lights).\n"
"SHADOW_MAPPING    -> Enables shadow mapping.\n"
"GLOBAL_ILLUMINATION  -> Enables global illumination (requires SHADOW_MAPPING).\n"
"BLOOM_FILTER      -> Enables bloom filter.\n"
"TILED_SHADING   -> Enables tiled deferred shading.\n"
"DEBUG_GBUFFER     -> Renders g-buffer for debugging.\n"
"DEBUG_GBUFFER_WORLDPOS -> Renders position-map instead of depth map.\n"
"HAS_LIGHT_MAP   -> Specifies that a lightmap is used.\n"
"ALLOW_OVERBLENDING  -> Allows the lighting to ober-blend.\n"
"*/\n"
"#extension GL_ARB_explicit_attrib_location : enable\n"
"#ifdef SHADOW_MAPPING\n"
"# extension GL_EXT_texture_array : enable\n"
"# extension GL_ARB_texture_cube_map_array : enable\n"
"# ifdef GLOBAL_ILLUMINATION\n"
"#  extension GL_EXT_gpu_shader4 : enable\n"
"# endif\n"
"#endif\n"
"uniform sampler2D DiffuseAndSpecularMap;\n"
"uniform sampler2D NormalAndDepthMap;\n"
"#ifdef HAS_LIGHT_MAP\n"
"uniform sampler2D IlluminationMap;\n"
"#endif\n"
"#if defined(GLOBAL_ILLUMINATION) && defined(USE_LOWRES_VPL_SHADING)\n"
"uniform sampler2D VPLColorMap;\n"
"#endif\n"
"#ifdef SHADOW_MAPPING\n"
"uniform sampler2DArray DirLightShadowMaps;\n"
"uniform samplerCubeArray PointLightShadowMaps;\n"
"# ifdef GLOBAL_ILLUMINATION\n"
"uniform sampler2DArray DirLightDiffuseMaps;\n"
"uniform samplerCubeArray PointLightDiffuseMaps;\n"
"# endif\n"
"#endif\n"
"#ifdef TILED_SHADING\n"
"uniform isamplerBuffer GlobalLightIdList;\n"
"uniform isamplerBuffer LightGrid;\n"
"uniform uint LightGridRowSize;\n"
"#endif\n"
"#ifdef GLOBAL_ILLUMINATION\n"
"uniform float GIReflectivity;\n"
"layout(std140) uniform BufferVPL\n"
"{\n"
" float4 VPLOffsets[VPL_COUNT];\n"
"};\n"
"#endif\n"
"uniform int LightCount;\n"
"layout(std140) uniform BufferLight\n"
"{\n"
" SLight Lights[MAX_LIGHTS];\n"
"};\n"
"layout(std140) uniform BufferLightEx\n"
"{\n"
" SLightEx LightsEx[MAX_EX_LIGHTS];\n"
"};\n"
"uniform float3 ViewPosition; //!< Global camera position.\n"
"uniform float3 AmbientColor; //!< Ambient light color.\n"
"in float2 TexCoord;\n"
"in float4 ViewRay;\n"
"layout(location = 0) out float4 OutColor;\n"
"#ifdef BLOOM_FILTER\n"
"layout(location = 1) out float4 OutSpecular;\n"
"#endif\n"
"/*\n"
" * Deferred shader procedures file\n"
" * \n"
" * This file is part of the \"SoftPixel Engine\" (Copyright (c) 2008 by Lukas Hermanns)\n"
" * See \"SoftPixelEngine.hpp\" for license information.\n"
" */\n"
"float GetAngle(float3 a, float3 b)\n"
"{\n"
"    return acos(dot(a, b));\n"
"}\n"
"float GetSpotLightIntensity(float3 LightDir, SLightEx LightEx)\n"
"{\n"
" float Angle = GetAngle(LightDir, LightEx.Direction);\n"
" float ConeAngleLerp = (Angle - LightEx.SpotTheta) / LightEx.SpotPhiMinusTheta;\n"
" return saturate(1.0 - ConeAngleLerp);\n"
"}\n"
"#ifdef TILED_SHADING\n"
"uint2 GetTilePos(float4 PixelPos)\n"
"{\n"
" return uint2(\n"
"  CAST(uint, PixelPos.x) / TILED_LIGHT_GRID_WIDTH,\n"
"  CAST(uint, PixelPos.y) / TILED_LIGHT_GRID_HEIGHT\n"
" );\n"
"}\n"
"#endif\n"
"#ifdef SHADOW_MAPPING\n"
"/**\n"
"Chebyshev inequality function for VSM (variance shadow maps)\n"
"see GPUGems3 at nVIDIA for more details:\n"
"http://http.developer.nvidia.com/GPUGems3/gpugems3_ch08.html\n"
"*/\n"
"float ChebyshevUpperBound(float2 Moments, float t)\n"
"{\n"
"    /* One-tailed inequality valid if t > Moments.x */\n"
" float p = step(t, Moments.x);\n"
"    /* Compute variance */\n"
"    float Variance = Moments.y - (Moments.x*Moments.x);\n"
"    Variance = max(Variance, MIN_VARIANCE);\n"
"    \n"
"    /* Compute probabilistic upper bound. */\n"
"    float d = t - Moments.x;\n"
"    float p_max = Variance / (Variance + d*d);\n"
"    \n"
"    return max(p, p_max);\n"
"}\n"
"float LinStep(float min, float max, float v)\n"
"{\n"
"    return saturate((v - min) / (max - min));\n"
"}\n"
"float ReduceLightBleeding(float p_max, float Amount)\n"
"{\n"
"    /* Remove the [0, amount] ail and linearly rescale [amount, 1] */\n"
"    return LinStep(Amount, 1.0, p_max);\n"
"}\n"
"float ShadowContribution(float2 Moments, float LightDistance)\n"
"{\n"
"    /* Compute the Chebyshev upper bound */\n"
"    float p_max = ChebyshevUpperBound(Moments, LightDistance);\n"
"    return ReduceLightBleeding(p_max, 0.6);\n"
"}\n"
"float4 Projection(float4x4 ProjectionMatrix, float4 WorldPos)\n"
"{\n"
"    float4 ProjectedPoint = MUL(ProjectionMatrix, WorldPos);\n"
"    ProjectedPoint.xy = (ProjectedPoint.xy / CAST(float2, ProjectedPoint.w) + CAST(float2, 1.0)) * CAST(float2, 0.5);\n"
"    return ProjectedPoint;\n"
"}\n"
"# ifdef GLOBAL_ILLUMINATION\n"
"bool ComputeVPLIntensity(float3 WorldPos, float3 Normal, float3 IndirectPoint, inout float IntensityIL)\n"
"{\n"
" float3 IndirectDir = IndirectPoint - WorldPos;\n"
" if (dot(Normal, IndirectDir) <= 0.0)\n"
"  return false;\n"
" float DistanceIL = distance(WorldPos, IndirectPoint);\n"
" float AttnLinearIL    = DistanceIL;// ... * VPLRadius;\n"
" float AttnQuadraticIL = AttnLinearIL * DistanceIL;\n"
" IntensityIL = saturate(1.0 / (1.0 + AttnLinearIL + AttnQuadraticIL));// - LIGHT_CUTOFF);\n"
" float NdotIL = saturate(dot(Normal, normalize(IndirectDir)));\n"
" IntensityIL = min(VPL_SINGULARITY_CLAMP, IntensityIL * NdotIL) * GIReflectivity;\n"
" return true;\n"
"}\n"
"void ComputeVPLShading(float3 WorldPos, float3 Normal, SVPL VPL, inout float3 Diffuse)\n"
"{\n"
" float Intensity = 0.0;\n"
" if (ComputeVPLIntensity(WorldPos, Normal, Intensity))\n"
"  Diffuse += VPL.Color * CAST(float3, Intensity);\n"
"}\n"
"void ComputeVPLShadingSpotLight(\n"
"    SLight Light, SLightEx LightEx, float3 WorldPos, float3 Normal, inout float3 Diffuse)\n"
"{\n"
" float3 IndirectTexCoord = float3(0.0, 0.0, float(Light.ShadowIndex));\n"
" for (int i = 0; i < VPL_COUNT; ++i)\n"
" {\n"
"  IndirectTexCoord.xy = VPLOffsets[i].xy;\n"
"  float IndirectDist = tex2DArray(DirLightShadowMaps, IndirectTexCoord).r;\n"
"  float4 LightRay = float4(IndirectTexCoord.x*2.0 - 1.0, 1.0 - IndirectTexCoord.y*2.0, 1.0, 1.0);\n"
"  LightRay = normalize(MUL(LightEx.InvViewProjection, LightRay));\n"
"  float3 IndirectPoint = Light.PositionAndInvRadius.xyz + LightRay.xyz * CAST(float3, IndirectDist);\n"
"  float IntensityIL = 0.0;\n"
"  if (ComputeVPLIntensity(WorldPos, Normal, IndirectPoint, IntensityIL))\n"
"  {\n"
"   float3 IndirectColor = tex2DArray(DirLightDiffuseMaps, IndirectTexCoord).rgb;\n"
"   IndirectColor *= CAST(float3, IntensityIL);\n"
"   Diffuse += IndirectColor;\n"
"  }\n"
" }\n"
"}\n"
"void ComputeLowResLightShadingVPL(\n"
"    SLight Light, SLightEx LightEx, float3 WorldPos,\n"
" float3 Normal, inout float3 Diffuse)\n"
"{\n"
"    /* Compute diffuse color */\n"
"    Diffuse = CAST(float3, 0.0);\n"
"    float3 Specular = CAST(float3, 0.0);\n"
"    /* Apply shadow */\n"
"    if (Light.ShadowIndex != -1)\n"
" {\n"
"  if (Light.Type == LIGHT_POINT)\n"
"  {\n"
"  }\n"
"  else if (Light.Type == LIGHT_SPOT)\n"
"   ComputeVPLShadingSpotLight(Light, LightEx, WorldPos, Normal, Diffuse);\n"
" }\n"
" Diffuse *= Light.Color;\n"
"}\n"
"# endif\n"
"#endif\n"
"void ComputeLightShading(\n"
"    SLight Light, SLightEx LightEx,\n"
"    float3 WorldPos, float3 Normal, float Shininess, float3 ViewRay,\n"
" #ifdef HAS_LIGHT_MAP\n"
" inout float3 StaticDiffuseColor, inout float3 StaticSpecularColor,\n"
" #endif\n"
"    inout float3 DiffuseColor, inout float3 SpecularColor)\n"
"{\n"
"    /* Compute light direction vector */\n"
"    float3 LightDir = CAST(float3, 0.0);\n"
"    if (Light.Type != LIGHT_DIRECTIONAL)\n"
"        LightDir = normalize(WorldPos - Light.PositionAndInvRadius.xyz);\n"
"    else\n"
"        LightDir = LightEx.Direction;\n"
"    /* Compute phong shading */\n"
"    float NdotL = max(AMBIENT_LIGHT_FACTOR, dot(Normal, -LightDir));\n"
"    /* Compute light attenuation */\n"
"    float Distance = distance(WorldPos, Light.PositionAndInvRadius.xyz);\n"
"    float AttnLinear    = Distance * Light.PositionAndInvRadius.w;\n"
"    float AttnQuadratic = AttnLinear * Distance;\n"
"    float Intensity = (1.0 + LIGHT_CUTOFF) / (1.0 + AttnLinear + AttnQuadratic) - LIGHT_CUTOFF;\n"
"    if (Light.Type == LIGHT_SPOT)\n"
"  Intensity *= GetSpotLightIntensity(LightDir, LightEx);\n"
"    /* Compute diffuse color */\n"
"    float3 Diffuse = CAST(float3, Intensity * NdotL);\n"
"    /* Compute specular color */\n"
"    float3 Reflection = normalize(reflect(LightDir, Normal));\n"
"    float NdotHV = -dot(ViewRay, Reflection);\n"
"    float3 Specular = Light.Color * CAST(float3, Intensity * pow(max(0.0, NdotHV), Shininess));\n"
"    #ifdef SHADOW_MAPPING\n"
"    /* Apply shadow */\n"
"    if (Light.ShadowIndex != -1)\n"
" {\n"
"  if (Light.Type == LIGHT_POINT)\n"
"  {\n"
"  }\n"
"  else if (Light.Type == LIGHT_SPOT)\n"
"  {\n"
"   float4 ShadowTexCoord = Projection(LightEx.ViewProjection, float4(WorldPos, 1.0));\n"
"   if ( ShadowTexCoord.x >= 0.0 && ShadowTexCoord.x <= 1.0 &&\n"
"     ShadowTexCoord.y >= 0.0 && ShadowTexCoord.y <= 1.0 &&\n"
"     ShadowTexCoord.z > 0.0 )\n"
"   {\n"
"    ShadowTexCoord.y = 1.0 - ShadowTexCoord.y;\n"
"    ShadowTexCoord.z = float(Light.ShadowIndex);\n"
"    ShadowTexCoord.w = 2.0;//Distance*0.25;\n"
"    float2 Moments = tex2DArrayLod(DirLightShadowMaps, ShadowTexCoord).ra;\n"
"    float Shadow = ShadowContribution(Moments, Distance);\n"
"    Diffuse *= CAST(float3, Shadow);\n"
"    Specular *= CAST(float3, Shadow);\n"
"   }\n"
"   #if defined(GLOBAL_ILLUMINATION) && !defined(USE_LOWRES_VPL_SHADING)\n"
"   if (GIReflectivity > 0.0)\n"
"    ComputeVPLShadingSpotLight(Light, LightEx, WorldPos, Normal, Diffuse);\n"
"   #endif\n"
"  }\n"
" }\n"
"    #endif\n"
" Diffuse *= Light.Color;\n"
"    /* Add light color */\n"
" #ifdef HAS_LIGHT_MAP\n"
" if (Light.UsedForLightmaps != 0)\n"
" {\n"
"  StaticDiffuseColor += Diffuse;\n"
"  StaticSpecularColor += Specular;\n"
" }\n"
" else\n"
" {\n"
"  DiffuseColor += Diffuse;\n"
"  SpecularColor += Specular;\n"
" }\n"
" #else\n"
"    DiffuseColor += Diffuse;\n"
"    SpecularColor += Specular;\n"
" #endif\n"
"}\n"
"void ComputeShading(\n"
"    float4 PixelPos, float3 WorldPos, float3 Normal, float Shininess, float3 ViewRay,\n"
" #ifdef HAS_LIGHT_MAP\n"
" inout float3 StaticDiffuseColor, inout float3 StaticSpecularColor,\n"
" #endif\n"
"    inout float3 DiffuseColor, inout float3 SpecularColor\n"
" #ifdef _DEB_TILES_\n"
" ,inout uint _DebTileNum_\n"
" #endif\n"
")\n"
"{\n"
" #ifdef TILED_SHADING\n"
" uint2 TilePos = GetTilePos(PixelPos);\n"
" uint TileIndex = TilePos.y * LightGridRowSize + TilePos.x;\n"
" uint Next = LightGrid[TileIndex];\n"
" # ifdef _DEB_USE_GROUP_SHARED_OPT_\n"
" while (1)\n"
" # else\n"
" while (Next != EOL)\n"
" # endif\n"
" {\n"
"  #ifndef _DEB_USE_GROUP_SHARED_OPT_\n"
"  SLightNode Node = GlobalLightIdList[Next];\n"
"  #endif\n"
"  #ifdef _DEB_USE_GROUP_SHARED_OPT_\n"
"  uint i = GlobalLightIdList[Next];\n"
"  if (i == EOL)\n"
"   break;\n"
"  ++Next;\n"
"  #else\n"
"  uint i = Node.LightID;\n"
"  Next = Node.Next;\n"
"  #endif\n"
"  #ifdef _DEB_TILES_\n"
"  ++_DebTileNum_;\n"
"  #endif\n"
" #else\n"
"    for (int i = 0; i < LightCount; ++i)\n"
"    {\n"
" #endif\n"
"  ComputeLightShading(\n"
"   Lights[i], LightsEx[Lights[i].ExID],\n"
"   WorldPos, Normal, SHININESS_FACTOR, ViewRay,\n"
"   #ifdef HAS_LIGHT_MAP\n"
"   StaticDiffuseColor, StaticSpecularColor,\n"
"   #endif\n"
"   DiffuseColor, SpecularColor\n"
"  );\n"
" #ifdef TILED_SHADING\n"
" }\n"
" #else\n"
"    }\n"
" #endif\n"
" #if defined(TILED_SHADING) && defined(GLOBAL_ILLUMINATION) && defined(_DEB_USE_GROUP_SHARED_OPT_)\n"
" while (1)\n"
" {\n"
"  uint i = GlobalLightIdList[Next];\n"
"  if (i == EOL)\n"
"   break;\n"
"  ++Next;\n"
"  #ifdef _DEB_TILES_\n"
"  ++_DebTileNum_;\n"
"  #endif\n"
"  ComputeVPLShading(WorldPos, Normal, VPLList[i], DiffuseLight);\n"
" }\n"
" #endif\n"
"}\n"
"#if defined(_DEB_TILES_) || defined(_DEB_DEPTH_EXTENT_)\n"
"void _DebDrawTileUsage_(float4 PixelPos, uint _DebTileNum_, inout float3 Color)\n"
"{\n"
" float3 c_list[11] =\n"
" {\n"
"  float3(0.0, 1.0, 0.0), float3(0.0, 0.8, 0.2),\n"
"  float3(0.0, 0.6, 0.4), float3(0.0, 0.4, 0.6),\n"
"  float3(0.0, 0.2, 0.8), float3(0.0, 0.0, 1.0),\n"
"  float3(0.2, 0.0, 0.8), float3(0.4, 0.0, 0.6),\n"
"  float3(0.6, 0.0, 0.4), float3(0.8, 0.0, 0.2),\n"
"  float3(1.0, 0.0, 0.0)\n"
" };\n"
" #ifdef _DEB_TILES_\n"
" if (_DebTileNum_ > 0)\n"
" {\n"
"  _DebTileNum_ /= 2;\n"
"  float3 c = c_list[min(_DebTileNum_, 10)];\n"
"  Color.rgb += c;\n"
" }\n"
" #endif\n"
" #ifdef _DEB_DEPTH_EXTENT_\n"
" uint2 TilePos = GetTilePos(PixelPos);\n"
" uint TileIndex = TilePos.y * LightGridRowSize + TilePos.x;\n"
" float2 depth_ext = _debDepthExt_Out[TileIndex].xy;\n"
" # if 0\n"
" float l = ((PixelPos.x / TILED_LIGHT_GRID_WIDTH) - (float)TilePos.x);\n"
" Color.rg = lerp((float2)depth_ext.r * 0.1, (float2)depth_ext.g * 0.1, l);\n"
" # else\n"
" int c_i = (int)(abs(depth_ext.x - depth_ext.y) * 0.5);\n"
" float3 c = c_list[min(c_i, 10)];\n"
" Color.rgb += c;\n"
" # endif\n"
" #endif\n"
"}\n"
"#endif\n"
"void main()\n"
"{\n"
"    /* Compute global pixel position (world space) */\n"
"    float4 NormalAndDepthDist = tex2D(NormalAndDepthMap, TexCoord);\n"
" float3 ViewRayNorm = normalize(ViewRay.xyz);\n"
"    float3 WorldPos = ViewPosition + ViewRayNorm * float3(NormalAndDepthDist.a);\n"
"    /* Compute light shading */\n"
" #ifdef HAS_LIGHT_MAP\n"
"    float3 StaticDiffuseLight = float3(0.0);\n"
"    float3 StaticSpecularLight = float3(0.0);\n"
"    #endif\n"
"    float3 DiffuseLight = AmbientColor;\n"
"    float3 SpecularLight = float3(0.0);\n"
" ComputeShading(\n"
"  gl_FragCoord, WorldPos, NormalAndDepthDist.xyz, SHININESS_FACTOR, ViewRayNorm,\n"
"  #ifdef HAS_LIGHT_MAP\n"
"  StaticDiffuseLight, StaticSpecularLight,\n"
"  #endif\n"
"  DiffuseLight, SpecularLight\n"
" );\n"
" #ifdef HAS_LIGHT_MAP\n"
" float Illumination = tex2D(IlluminationMap, TexCoord).r;\n"
" DiffuseLight += (StaticDiffuseLight * float3(Illumination));\n"
" SpecularLight += (StaticSpecularLight * float3(Illumination));\n"
" #endif\n"
" #if defined(GLOBAL_ILLUMINATION) && defined(USE_LOWRES_VPL_SHADING)\n"
" DiffuseLight += tex2D(VPLColorMap, TexCoord).rgb;\n"
" #endif\n"
" #ifndef ALLOW_OVERBLENDING\n"
" DiffuseLight = saturate(DiffuseLight);\n"
" SpecularLight = saturate(SpecularLight);\n"
" #endif\n"
"    /* Get diffuse and specular colors */\n"
" float4 DiffuseAndSpecular = tex2D(DiffuseAndSpecularMap, TexCoord);\n"
"    DiffuseLight *= DiffuseAndSpecular.rgb;\n"
"    SpecularLight *= float3(DiffuseAndSpecular.a);\n"
"    /* Compute final deferred shaded pixel color */\n"
"    OutColor.rgb = DiffuseLight + SpecularLight;\n"
"    OutColor.a  = 1.0;\n"
" #ifdef BLOOM_FILTER\n"
"    OutSpecular.rgb = SpecularLight;\n"
"    OutSpecular.a = 1.0;\n"
"    #endif\n"
"    \n"
"    #ifdef DEBUG_GBUFFER\n"
" #   ifdef DEBUG_GBUFFER_WORLDPOS\n"
" WorldPos += 0.01;\n"
"    OutColor.rgb = WorldPos - floor(WorldPos);\n"
" #   else\n"
"    //Out.Color.rgb = float3(NormalAndDepthDist.a - floor(NormalAndDepthDist.a));\n"
" OutColor.rgb = NormalAndDepthDist.xyz * float3(0.5) + float3(0.5);\n"
" #   endif\n"
"    #endif\n"
"}\n"
