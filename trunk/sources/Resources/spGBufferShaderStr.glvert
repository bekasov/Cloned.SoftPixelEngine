"/*\n"
" * GBuffer GLSL vertex shader file\n"
" * \n"
" * This file is part of the \"SoftPixel Engine\" (Copyright (c) 2008 by Lukas Hermanns)\n"
" * See \"SoftPixelEngine.hpp\" for license information.\n"
" */\n"
"#version 120\n"
"/*\n"
" * GLSL shader core file\n"
" * \n"
" * This file is part of the \"SoftPixel Engine\" (Copyright (c) 2008 by Lukas Hermanns)\n"
" * See \"SoftPixelEngine.hpp\" for license information.\n"
" */\n"
"#define PI   3.14159265359\n"
"#define E   2.71828182846\n"
"#define float2  vec2\n"
"#define float3  vec3\n"
"#define float4  vec4\n"
"#define double2  dvec2\n"
"#define double3  dvec3\n"
"#define double4  dvec4\n"
"#define bool2  bvec2\n"
"#define bool3  bvec3\n"
"#define bool4  bvec4\n"
"#define int2  ivec2\n"
"#define int3  ivec3\n"
"#define int4  ivec4\n"
"#define uint2  uvec2\n"
"#define uint3  uvec3\n"
"#define uint4  uvec4\n"
"#define half  float\n"
"#define half2  vec2\n"
"#define half3  vec3\n"
"#define half4  vec4\n"
"#define float2x2 mat2\n"
"#define float3x3 mat3\n"
"#define float4x4 mat4\n"
"#define float2x3 mat2x3\n"
"#define float2x4 mat2x4\n"
"#define float3x2 mat3x2\n"
"#define float3x4 mat3x4\n"
"#define float4x2 mat4x2\n"
"#define float4x3 mat4x3\n"
"#define double2x2 dmat2\n"
"#define double3x3 dmat3\n"
"#define double4x4 dmat4\n"
"#define double2x3 dmat2x3\n"
"#define double2x4 dmat2x4\n"
"#define double3x2 dmat3x2\n"
"#define double3x4 dmat3x4\n"
"#define double4x2 dmat4x2\n"
"#define double4x3 dmat4x3\n"
"#define bool2x2  bmat2\n"
"#define bool3x3  bmat3\n"
"#define bool4x4  bmat4\n"
"#define bool2x3  bmat2x3\n"
"#define bool2x4  bmat2x4\n"
"#define bool3x2  bmat3x2\n"
"#define bool3x4  bmat3x4\n"
"#define bool4x2  bmat4x2\n"
"#define bool4x3  bmat4x3\n"
"#define int2x2  imat2\n"
"#define int3x3  imat3\n"
"#define int4x4  imat4\n"
"#define int2x3  imat2x3\n"
"#define int2x4  imat2x4\n"
"#define int3x2  imat3x2\n"
"#define int3x4  imat3x4\n"
"#define int4x2  imat4x2\n"
"#define int4x3  imat4x3\n"
"#define uint2x2  umat2\n"
"#define uint3x3  umat3\n"
"#define uint4x4  umat4\n"
"#define uint2x3  umat2x3\n"
"#define uint2x4  umat2x4\n"
"#define uint3x2  umat3x2\n"
"#define uint3x4  umat3x4\n"
"#define uint4x2  umat4x2\n"
"#define uint4x3  umat4x3\n"
"#define MUL(m, v)    (m) * (v)\n"
"#define MUL_TRANSPOSED(m, v) transpose(m) * (v)\n"
"#define MUL_NORMAL(n)   (n).xyz = float3x3(Tangent, Binormal, Normal) * (n).xyz\n"
"#define CAST(t, v)    (t(v))\n"
"#define SAMPLER2D(n, i)   uniform sampler2D n\n"
"#define saturate(v)    clamp(v, 0.0, 1.0)\n"
"#define clip(v)     if (v < 0.0) { discard; }\n"
"#define frac(v)     fract(v)\n"
"#define lerp(x, y, s)   mix(x, y, s)\n"
"#define tex2D     texture2D\n"
"#define tex2Dgrad    texture2DGradARB\n"
"#define tex2DArrayLod(s, t)  texture2DArrayLod(s, (t).xyz, (t).w)\n"
"#define tex2DArray(s, t)  texture2DArray(s, t)\n"
"#define tex2DGrad(s, t, dx, dy) texture2DGradARB(s, t, dx, dy)\n"
"#define ddx(v)     dFdx(v)\n"
"#define ddy(v)     dFdy(v)\n"
"#define DeclStructuredBuffer(s, n, r)      \\\n"
" layout(std430, binding = r) readonly buffer Buffer##n \\\n"
" {              \\\n"
"  s n[];            \\\n"
" }\n"
"#define DeclBuffer(t, n, r)         \\\n"
" layout(std430, binding = r) readonly buffer Buffer##n \\\n"
" {              \\\n"
"  t n[];            \\\n"
" }\n"
"#define DeclRWStructuredBuffer(s, n, r)    \\\n"
" layout(std430, binding = r) buffer Buffer##n \\\n"
" {            \\\n"
"  s n[];          \\\n"
" }\n"
"#define DeclRWBuffer(t, n, r)      \\\n"
" layout(std430, binding = r) buffer Buffer##n \\\n"
" {            \\\n"
"  t n[];          \\\n"
" }\n"
"#define DeclConstBuffer(n, r)       layout(std140, binding = r) uniform n\n"
"#define RWTexture3DUInt         layout(r32ui) coherent volatile uimage3D\n"
"#define groupshared          shared\n"
"#define floatBitsToUInt(v)        floatBitsToUint(v)\n"
"#define InterlockedAdd(d, v, o)       o = atomicAdd(d, v)\n"
"#define InterlockedAnd(d, v, o)       o = atomicAnd(d, v)\n"
"#define InterlockedOr(d, v, o)       o = atomicOr(d, v)\n"
"#define InterlockedXor(d, v, o)       o = atomicXor(d, v)\n"
"#define InterlockedMin(d, v, o)       o = atomicMin(d, v)\n"
"#define InterlockedMax(d, v, o)       o = atomicMax(d, v)\n"
"#define InterlockedCompareExchange(d, v, o)    o = atomicCompSwap(d, v)\n"
"#define InterlockedExchange(d, v, o)     o = atomicExchange(d, v)\n"
"#define GroupMemoryBarrier        groupMemoryBarrier\n"
"#define InterlockedImageCompareExchange(i, p, c, v, o) o = imageAtomicCompSwap(i, p, c, v)\n"
"/*\n"
"Compilation options:\n"
"USE_TEXTURE_MATRIX  -> Enables texture matrix transformations for texture coordinates.\n"
"NORMAL_MAPPING      -> Enables normal mapping.\n"
"PARALLAX_MAPPING    -> Enables parallax-occlusion mapping (Requires NORMAL_MAPPING to be enabled).\n"
"HAS_LIGHT_MAP  -> Specifies that a lightmap is used.\n"
"*/\n"
"uniform float4x4 WorldViewProjectionMatrix;\n"
"uniform float4x4 WorldMatrix;\n"
"#ifdef USE_TEXTURE_MATRIX\n"
"uniform float4x4 TextureMatrix;\n"
"#endif\n"
"uniform float3 ViewPosition;    //!< Global camera position.\n"
"varying float3 WorldPos;\n"
"varying float3 Normal;\n"
"varying float2 TexCoord;\n"
"#ifdef HAS_LIGHT_MAP\n"
"varying float2 LMTexCoord;\n"
"#endif\n"
"#ifdef NORMAL_MAPPING\n"
"varying float3 Tangent;\n"
"varying float3 Binormal;\n"
"#   ifdef PARALLAX_MAPPING\n"
"varying float4 ViewVertexDirAndDepth;\n"
"#   endif\n"
"#endif\n"
"void main()\n"
"{\n"
"    /* Process vertex transformation for position and normal */\n"
" float3x3 NormalMatrix = float3x3(WorldMatrix);\n"
"    gl_Position = WorldViewProjectionMatrix * gl_Vertex;\n"
"    WorldPos    = float3(WorldMatrix * gl_Vertex);\n"
"    Normal      = normalize(NormalMatrix * gl_Normal);\n"
"    #ifdef NORMAL_MAPPING\n"
"    \n"
"    /* Process transformation for tangent space */\n"
"    Tangent     = normalize(NormalMatrix * gl_MultiTexCoord1.xyz);\n"
"    Binormal    = normalize(NormalMatrix * gl_MultiTexCoord2.xyz);\n"
"    #   ifdef PARALLAX_MAPPING\n"
"    NormalMatrix = float3x3(\n"
"        Tangent,\n"
"        Binormal,\n"
"        Normal\n"
"    );\n"
"    ViewVertexDirAndDepth.xyz   = ViewPosition - WorldPos;\n"
"    ViewVertexDirAndDepth.xyz   = transpose(NormalMatrix) * ViewVertexDirAndDepth.xyz;\n"
"    ViewVertexDirAndDepth.y     = -ViewVertexDirAndDepth.y;\n"
"    ViewVertexDirAndDepth.w     = gl_Position.z;\n"
"    #   endif\n"
"    #endif\n"
"    #ifdef USE_TEXTURE_MATRIX\n"
"    TexCoord = float2(TextureMatrix * float4(gl_MultiTexCoord0, 0.0, 1.0));\n"
"    #else\n"
"    TexCoord = gl_MultiTexCoord0.xy;\n"
"    #endif\n"
" #ifdef HAS_LIGHT_MAP\n"
" LMTexCoord = gl_MultiTexCoord3.xy;\n"
" #endif\n"
"}\n"
