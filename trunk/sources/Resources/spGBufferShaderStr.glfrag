"/*\n"
" * GBuffer GLSL fragment shader file\n"
" * \n"
" * This file is part of the \"SoftPixel Engine\" (Copyright (c) 2008 by Lukas Hermanns)\n"
" * See \"SoftPixelEngine.hpp\" for license information.\n"
" */\n"
"#version 120\n"
"/*\n"
" * GLSL shader core file\n"
" * \n"
" * This file is part of the \"SoftPixel Engine\" (Copyright (c) 2008 by Lukas Hermanns)\n"
" * See \"SoftPixelEngine.hpp\" for license information.\n"
" */\n"
"#define PI   3.14159265359\n"
"#define E   2.71828182846\n"
"#define float2  vec2\n"
"#define float3  vec3\n"
"#define float4  vec4\n"
"#define double2  dvec2\n"
"#define double3  dvec3\n"
"#define double4  dvec4\n"
"#define bool2  bvec2\n"
"#define bool3  bvec3\n"
"#define bool4  bvec4\n"
"#define int2  ivec2\n"
"#define int3  ivec3\n"
"#define int4  ivec4\n"
"#define uint2  uvec2\n"
"#define uint3  uvec3\n"
"#define uint4  uvec4\n"
"#define float2x2 mat2\n"
"#define float3x3 mat3\n"
"#define float4x4 mat4\n"
"#define half  float\n"
"#define half2  vec2\n"
"#define half3  vec3\n"
"#define half4  vec4\n"
"#define MUL(m, v)    (m) * (v)\n"
"#define MUL_TRANSPOSED(m, v) transpose(m) * (v)\n"
"#define MUL_NORMAL(n)   (n).xyz = float3x3(Tangent, Binormal, Normal) * (n).xyz\n"
"#define CAST(t, v)    (t(v))\n"
"#define SAMPLER2D(n, i)   uniform sampler2D n\n"
"#define saturate(v)    clamp(v, 0.0, 1.0)\n"
"#define clip(v)     if (v < 0.0) { discard; }\n"
"#define frac(v)     fract(v)\n"
"#define lerp(x, y, s)   mix(x, y, s)\n"
"#define tex2D     texture2D\n"
"#define tex2Dgrad    texture2DGradARB\n"
"#define tex2DArrayLod(s, t)  texture2DArrayLod(s, (t).xyz, (t).w)\n"
"#define tex2DArray(s, t)  texture2DArray(s, t)\n"
"#define tex2DGrad(s, t, x, y) texture2DGradARB(s, t, x, y)\n"
"#define ddx(v)     dFdx(v)\n"
"#define ddy(v)     dFdy(v)\n"
"#define RWTexture3DUInt         layout (r32ui) coherent volatile uimage3D\n"
"#define floatBitsToUInt(v)        floatBitsToUint(v)\n"
"#define InterlockedAdd(d, v, o)       o = atomicAdd(d, v)\n"
"#define InterlockedAnd(d, v, o)       o = atomicAnd(d, v)\n"
"#define InterlockedOr(d, v, o)       o = atomicOr(d, v)\n"
"#define InterlockedXor(d, v, o)       o = atomicXor(d, v)\n"
"#define InterlockedMin(d, v, o)       o = atomicMin(d, v)\n"
"#define InterlockedMax(d, v, o)       o = atomicMax(d, v)\n"
"#define InterlockedCompareExchange(d, v, o)    o = atomicCompSwap(d, v)\n"
"#define InterlockedExchange(d, v, o)     o = atomicExchange(d, v)\n"
"#define InterlockedImageCompareExchange(i, p, c, v, o) o = imageAtomicCompSwap(i, p, c, v)\n"
"/*\n"
"Compilation options:\n"
"NORMAL_MAPPING      -> Enables normal mapping.\n"
"PARALLAX_MAPPING    -> Enables parallax-occlusion mapping (Requires NORMAL_MAPPING to be enabled).\n"
"NORMALMAP_XYZ_H  -> Normal map contains vector data (xyz in RGB) and height-field data (h in Alpha-Channel). When this is defined, no height-map is used for parallax-mapping.\n"
"HAS_SPECULAR_MAP    -> Specifies that a specular is used.\n"
"HAS_LIGHT_MAP  -> Specifies that a lightmap is used.\n"
"*/\n"
"#ifdef PARALLAX_MAPPING\n"
"# ifdef GL_ARB_shader_texture_lod\n"
"#  extension GL_ARB_shader_texture_lod : enable\n"
"# else\n"
"#  undef PARALLAX_MAPPING\n"
"# endif\n"
"#endif\n"
"uniform sampler2D DiffuseMap;\n"
"#ifdef HAS_SPECULAR_MAP\n"
"uniform sampler2D SpecularMap;\n"
"#endif\n"
"#ifdef HAS_LIGHT_MAP\n"
"uniform sampler2D LightMap;\n"
"uniform bool EnableLightMap;\n"
"#endif\n"
"#ifdef NORMAL_MAPPING\n"
"uniform sampler2D NormalMap;\n"
"#   if defined(PARALLAX_MAPPING) && !defined(NORMALMAP_XYZ_H)\n"
"uniform sampler2D HeightMap;\n"
"#   endif\n"
"#   ifdef PARALLAX_MAPPING\n"
"uniform bool EnablePOM;\n"
"uniform int MinSamplesPOM;\n"
"uniform int MaxSamplesPOM;\n"
"uniform float HeightMapScale;\n"
"uniform float ParallaxViewRange;\n"
"#   endif\n"
"#endif\n"
"uniform float SpecularFactor;\n"
"uniform float3 ViewPosition;    //!< Global camera position.\n"
"/*#if GLSL_VERSION >= 150\n"
"layout(early_fragment_tests) in;\n"
"#endif*/\n"
"varying float3 WorldPos;\n"
"varying float3 Normal;\n"
"varying float2 TexCoord;\n"
"#ifdef HAS_LIGHT_MAP\n"
"varying float2 LMTexCoord;\n"
"#endif\n"
"#ifdef NORMAL_MAPPING\n"
"varying float3 Tangent;\n"
"varying float3 Binormal;\n"
"#   ifdef PARALLAX_MAPPING\n"
"varying float4 ViewVertexDirAndDepth;\n"
"#   endif\n"
"#endif\n"
"void main()\n"
"{\n"
"    float4 DiffuseAndSpecular = float4(0.0);\n"
"    float4 NormalAndDepth = float4(0.0);\n"
"/*\n"
" * GBuffer pixel shader main file\n"
" * \n"
" * This file is part of the \"SoftPixel Engine\" (Copyright (c) 2008 by Lukas Hermanns)\n"
" * See \"SoftPixelEngine.hpp\" for license information.\n"
" */\n"
"#ifndef NORMAL_MAPPING\n"
"DiffuseAndSpecular = tex2D(DiffuseMap, TexCoord);\n"
"#   ifdef HAS_SPECULAR_MAP\n"
"DiffuseAndSpecular.a = tex2D(SpecularMap, TexCoord).r * SpecularFactor;\n"
"#   endif\n"
"NormalAndDepth.xyz = Normal;\n"
"#else\n"
"#   ifdef PARALLAX_MAPPING\n"
"if (!EnablePOM)\n"
"{\n"
"#   endif\n"
" DiffuseAndSpecular = tex2D(DiffuseMap, TexCoord);\n"
" clip(DiffuseAndSpecular.a - 0.5);\n"
" NormalAndDepth.xyz = tex2D(NormalMap, TexCoord).rgb;\n"
" #ifdef HAS_SPECULAR_MAP\n"
" DiffuseAndSpecular.a = tex2D(SpecularMap, TexCoord).r * SpecularFactor;\n"
" #endif\n"
"#   ifdef PARALLAX_MAPPING\n"
"}\n"
"else\n"
"{\n"
" float ParallaxLimit = (length(ViewVertexDirAndDepth.xy) / ViewVertexDirAndDepth.z) * HeightMapScale;\n"
" float2 Offset       = normalize(-ViewVertexDirAndDepth.xy) * ParallaxLimit;\n"
" float Interpolation = saturate(ParallaxViewRange / ViewVertexDirAndDepth.w);\n"
" int NumSamples      = int(lerp(float(MinSamplesPOM), float(MaxSamplesPOM), Interpolation));\n"
" float StepSize      = 1.0 / float(NumSamples);\n"
" float2 dx           = ddx(TexCoord);\n"
" float2 dy           = ddy(TexCoord);\n"
" float2 OffsetStep   = Offset * StepSize;\n"
" float2 CurOffset    = CAST(float2, 0.0);\n"
" float2 PrevOffset   = CAST(float2, 0.0);\n"
" float CurSample     = 0.0;\n"
" float PrevSample    = 0.0;\n"
" float StepHeight    = 1.0;\n"
" int SampleIndex     = 0;\n"
" while (SampleIndex < NumSamples)\n"
" {\n"
"  #ifdef NORMALMAP_XYZ_H\n"
"  CurSample = tex2DGrad(NormalMap, TexCoord + CurOffset, dx, dy).a;\n"
"  #else\n"
"  CurSample = tex2DGrad(HeightMap, TexCoord + CurOffset, dx, dy).r;\n"
"  #endif\n"
"  if (CurSample > StepHeight)\n"
"  {\n"
"   float Ua = (PrevSample - (StepHeight + StepSize)) / (StepSize + (CurSample - PrevSample));\n"
"   CurOffset = PrevOffset + OffsetStep * Ua;\n"
"   break;\n"
"  }\n"
"  else\n"
"  {\n"
"   ++SampleIndex;\n"
"   StepHeight -= StepSize;\n"
"   PrevOffset = CurOffset;\n"
"   CurOffset += OffsetStep;\n"
"   PrevSample = CurSample;\n"
"  }\n"
" }\n"
" DiffuseAndSpecular = tex2DGrad(DiffuseMap, TexCoord + CurOffset, dx, dy);\n"
" NormalAndDepth.xyz = tex2DGrad(NormalMap, TexCoord + CurOffset, dx, dy).rgb;\n"
" #ifdef HAS_SPECULAR_MAP\n"
" DiffuseAndSpecular.a = tex2DGrad(SpecularMap, TexCoord + CurOffset, dx, dy).r * SpecularFactor;\n"
" #endif\n"
"}\n"
"#   endif // /PARALLAX_MAPPING\n"
"NormalAndDepth.xyz = NormalAndDepth.xyz * 2.0 - 1.0;\n"
"MUL_NORMAL(NormalAndDepth.xyz);\n"
"#endif // /NORMAL_MAPPING\n"
"#ifndef HAS_SPECULAR_MAP\n"
"DiffuseAndSpecular.a = SpecularFactor;\n"
"#endif\n"
"NormalAndDepth.a = distance(ViewPosition, WorldPos);\n"
"    gl_FragData[0] = DiffuseAndSpecular;\n"
"    gl_FragData[1] = NormalAndDepth;\n"
" #ifdef HAS_LIGHT_MAP\n"
" float Illumination = 1.0;\n"
" if (EnableLightMap)\n"
"  Illumination = tex2D(LightMap, LMTexCoord).r;\n"
" gl_FragData[2].r = Illumination;\n"
" #endif\n"
" #if defined(DEBUG_GBUFFER) && defined(DEBUG_GBUFFER_TEXCOORDS)\n"
" gl_FragData[0] = float4(\n"
"  TexCoord.x - floor(TexCoord.x),\n"
"  TexCoord.y - floor(TexCoord.y),\n"
"  0.0,\n"
"  1.0\n"
" );\n"
" #endif\n"
"}\n"
