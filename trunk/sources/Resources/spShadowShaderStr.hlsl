"/*\n"
" * Shadow D3D11 shader file\n"
" * \n"
" * This file is part of the \"SoftPixel Engine\" (Copyright (c) 2008 by Lukas Hermanns)\n"
" * See \"SoftPixelEngine.hpp\" for license information.\n"
" */\n"
"/*\n"
" * HLSL (SM 5) shader core file\n"
" * \n"
" * This file is part of the \"SoftPixel Engine\" (Copyright (c) 2008 by Lukas Hermanns)\n"
" * See \"SoftPixelEngine.hpp\" for license information.\n"
" */\n"
"#define PI      3.14159265359\n"
"#define E      2.71828182846\n"
"#define MUL(m, v)    mul(m, v)\n"
"#define MUL_TRANSPOSED(v, m) mul(v, m)\n"
"#define MUL_NORMAL(n)   (n).xyz = mul((n).xyz, float3x3(Tangent, Binormal, Normal))\n"
"#define CAST(t, v)    ((t)(v))\n"
"#define SAMPLER2D(n, i)   Texture2D n : register(t##i); SamplerState Sampler##n : register(s##i)\n"
"#define SAMPLER2DARRAY(n, i) Texture2DArray n : register(t##i); SamplerState Sampler##n : register(s##i)\n"
"#define SAMPLERCUBEARRAY(n, i) TextureCubeArray n : register(t##i); SamplerState Sampler##n : register(s##i)\n"
"#define mod(a, b)    fmod(a, b)\n"
"#define floatBitsToInt(v)  asint(v)\n"
"#define floatBitsToUInt(v)  asuint(v)\n"
"#define intBitsToFloat(v)  asfloat(v)\n"
"#define uintBitsToFloat(v)  asfloat(v)\n"
"#define tex2D(s, t)    s.Sample(Sampler##s, t)\n"
"#define tex2DArray(s, t)  s.Sample(Sampler##s, t)\n"
"#define tex2DArrayLod(s, t)  s.SampleLevel(Sampler##s, t.xyz, t.w)\n"
"#define tex2DGrad(s, t, dx, dy) s.SampleGrad(Sampler##s, t, dx, dy)\n"
"#define RWTexture3DUInt   RWTexture3D<uint>\n"
"#define DeclStructuredBuffer(s, n, r) StructuredBuffer<s> n : register(t##r)\n"
"#define DeclBuffer(t, n, r)    Buffer<t> n : register(t##r)\n"
"#define DeclRWStructuredBuffer(s, n, r) RWStructuredBuffer<s> n : register(u##r)\n"
"#define DeclRWBuffer(t, n, r)   RWBuffer<t> n : register(u##r)\n"
"#define DeclConstBuffer(n, r)   cbuffer n : register(b##r)\n"
"inline void InterlockedImageCompareExchange(RWTexture3DUInt Image, int3 Coord, uint Compare, uint Value, out uint Result)\n"
"{\n"
" InterlockedCompareExchange(Image[Coord], Compare, Value, Result);\n"
"}\n"
"/*\n"
"Compilation options:\n"
"USE_VSM             -> Enables use of VSMs (variance shadow maps).\n"
"USE_RSM    -> Enables use of RMSs (reflective shadow maps).\n"
"USE_TEXTURE         -> Enables use of one texture for alpha test.\n"
"USE_TEXTURE_MATRIX  -> Enables texture matrix transformations for texture coordinates.\n"
"*/\n"
"/*\n"
" * ======= Vertex shader: =======\n"
" */\n"
"struct SVertexInput\n"
"{\n"
"    float3 Position : POSITION;\n"
"    #if defined(USE_TEXTURE) || defined(USE_RSM)\n"
"    float2 TexCoord : TEXCOORD0;\n"
"    #endif\n"
"};\n"
"struct SVertexOutput\n"
"{\n"
"    float4 Position : SV_Position;\n"
"    float3 WorldPos : TEXCOORD0;\n"
"    #if defined(USE_TEXTURE) || defined(USE_RSM)\n"
"    float2 TexCoord : TEXCOORD1;\n"
"    #endif\n"
"};\n"
"cbuffer BufferMain : register(b0)\n"
"{\n"
"    float4x4 WorldViewProjectionMatrix;\n"
"    float4x4 WorldMatrix;\n"
"    float4x4 TextureMatrix;\n"
"    float4 ViewPosition;                //!< Global camera position.\n"
"};\n"
"SVertexOutput VertexMain(SVertexInput In)\n"
"{\n"
"    SVertexOutput Out = (SVertexOutput)0;\n"
"    \n"
"    /* Process vertex transformation for perspective- and global position */\n"
"    Out.Position = mul(WorldViewProjectionMatrix, float4(In.Position, 1.0));\n"
"    Out.WorldPos = mul(WorldMatrix, float4(In.Position, 1.0)).xyz;\n"
"    /* Process texture coordinate */\n"
"    #ifdef USE_TEXTURE\n"
"    #   ifdef USE_TEXTURE_MATRIX\n"
"    Out.TexCoord = (float2)mul(TextureMatrix, float4(In.TexCoord, 0.0, 1.0));\n"
"    #   else\n"
"    Out.TexCoord = In.TexCoord;\n"
"    #   endif\n"
"    #endif\n"
"    return Out;\n"
"}\n"
"/*\n"
" * ======= Pixel shader: =======\n"
" */\n"
"struct SPixelOutput\n"
"{\n"
"    #ifdef USE_VSM\n"
"    float4 DepthDist : SV_Target0;\n"
"    #else\n"
"    float DepthDist  : SV_Target0;\n"
"    #endif\n"
" #ifdef USE_RSM\n"
" float3 Color  : SV_Target1;\n"
" #endif\n"
"};\n"
"#if defined(USE_RSM)\n"
"SAMPLER2D(DiffuseMap, 0);\n"
"#elif defined(USE_TEXTURE)\n"
"SAMPLER2D(AlphaMap, 0);\n"
"#endif\n"
"#ifdef USE_VSM\n"
"/*\n"
" * Shadow shader procedures file\n"
" * \n"
" * This file is part of the \"SoftPixel Engine\" (Copyright (c) 2008 by Lukas Hermanns)\n"
" * See \"SoftPixelEngine.hpp\" for license information.\n"
" */\n"
"#ifdef USE_VSM\n"
"float2 ComputeMoments(float Depth)\n"
"{\n"
"    float2 Moments;\n"
"    \n"
"    // First moment is the depth itself\n"
"    Moments.x = Depth;\n"
"    \n"
"    // Compute partial derivatives of depth\n"
"    float dx = ddx(Depth);\n"
"    float dy = ddy(Depth);\n"
"    \n"
"    Moments.y = Depth*Depth + 0.25 * (dx*dx + dy*dy);\n"
"    \n"
"    return Moments;\n"
"}\n"
"#endif\n"
"#endif\n"
"#define DEPTH_DIST Out.DepthDist\n"
"#define WORLD_POS In.WorldPos\n"
"#define TEX_COORD In.TexCoord\n"
"SPixelOutput PixelMain(SVertexOutput In)\n"
"{\n"
"    SPixelOutput Out = (SPixelOutput)0;\n"
"    \n"
"/*\n"
" * Shadow pixel shader main file\n"
" * \n"
" * This file is part of the \"SoftPixel Engine\" (Copyright (c) 2008 by Lukas Hermanns)\n"
" * See \"SoftPixelEngine.hpp\" for license information.\n"
" */\n"
"#if defined(USE_RSM)\n"
"float4 Diffuse = tex2D(DiffuseMap, TEX_COORD);\n"
"clip(Diffuse.a - 0.5);\n"
"#elif defined(USE_TEXTURE)\n"
"clip(tex2D(AlphaMap, TEX_COORD).a - 0.5);\n"
"#endif\n"
"float Depth = distance(WORLD_POS, ViewPosition.xyz);\n"
"#ifdef USE_VSM\n"
"float2 Moments = ComputeMoments(Depth);\n"
"DEPTH_DIST.r = Moments.x;\n"
"DEPTH_DIST.a = Moments.y;\n"
"#else\n"
"DEPTH_DIST = Depth;\n"
"#endif\n"
" #ifdef USE_RSM\n"
" Out.Color = Diffuse.rgb;\n"
" #endif\n"
"    return Out;\n"
"}\n"
