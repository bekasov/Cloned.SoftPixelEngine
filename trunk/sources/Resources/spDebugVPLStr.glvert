"/*\n"
" * Debug VPL GLSL vertex shader file\n"
" * \n"
" * This file is part of the \"SoftPixel Engine\" (Copyright (c) 2008 by Lukas Hermanns)\n"
" * See \"SoftPixelEngine.hpp\" for license information.\n"
" */\n"
"#version 330\n"
"/*\n"
" * GLSL shader core file\n"
" * \n"
" * This file is part of the \"SoftPixel Engine\" (Copyright (c) 2008 by Lukas Hermanns)\n"
" * See \"SoftPixelEngine.hpp\" for license information.\n"
" */\n"
"#define PI   3.14159265359\n"
"#define E   2.71828182846\n"
"#define float2  vec2\n"
"#define float3  vec3\n"
"#define float4  vec4\n"
"#define double2  dvec2\n"
"#define double3  dvec3\n"
"#define double4  dvec4\n"
"#define bool2  bvec2\n"
"#define bool3  bvec3\n"
"#define bool4  bvec4\n"
"#define int2  ivec2\n"
"#define int3  ivec3\n"
"#define int4  ivec4\n"
"#define uint2  uvec2\n"
"#define uint3  uvec3\n"
"#define uint4  uvec4\n"
"#define float2x2 mat2\n"
"#define float3x3 mat3\n"
"#define float4x4 mat4\n"
"#define half  float\n"
"#define half2  vec2\n"
"#define half3  vec3\n"
"#define half4  vec4\n"
"#define MUL(m, v)    (m) * (v)\n"
"#define MUL_TRANSPOSED(m, v) transpose(m) * (v)\n"
"#define MUL_NORMAL(n)   (n).xyz = float3x3(Tangent, Binormal, Normal) * (n).xyz\n"
"#define CAST(t, v)    (t(v))\n"
"#define SAMPLER2D(n, i)   uniform sampler2D n\n"
"#define saturate(v)    clamp(v, 0.0, 1.0)\n"
"#define clip(v)     if (v < 0.0) { discard; }\n"
"#define frac(v)     fract(v)\n"
"#define lerp(x, y, s)   mix(x, y, s)\n"
"#define tex2D     texture2D\n"
"#define tex2Dgrad    texture2DGradARB\n"
"#define tex2DArrayLod(s, t)  texture2DArrayLod(s, (t).xyz, (t).w)\n"
"#define tex2DArray(s, t)  texture2DArray(s, t)\n"
"#define tex2DGrad(s, t, x, y) texture2DGradARB(s, t, x, y)\n"
"#define ddx(v)     dFdx(v)\n"
"#define ddy(v)     dFdy(v)\n"
"#define RWTexture3DUInt         layout (r32ui) coherent volatile uimage3D\n"
"#define floatBitsToUInt(v)        floatBitsToUint(v)\n"
"#define InterlockedAdd(d, v, o)       o = atomicAdd(d, v)\n"
"#define InterlockedAnd(d, v, o)       o = atomicAnd(d, v)\n"
"#define InterlockedOr(d, v, o)       o = atomicOr(d, v)\n"
"#define InterlockedXor(d, v, o)       o = atomicXor(d, v)\n"
"#define InterlockedMin(d, v, o)       o = atomicMin(d, v)\n"
"#define InterlockedMax(d, v, o)       o = atomicMax(d, v)\n"
"#define InterlockedCompareExchange(d, v, o)    o = atomicCompSwap(d, v)\n"
"#define InterlockedExchange(d, v, o)     o = atomicExchange(d, v)\n"
"#define InterlockedImageCompareExchange(i, p, c, v, o) o = imageAtomicCompSwap(i, p, c, v)\n"
"/*\n"
" * Deferred shader header file\n"
" * \n"
" * This file is part of the \"SoftPixel Engine\" (Copyright (c) 2008 by Lukas Hermanns)\n"
" * See \"SoftPixelEngine.hpp\" for license information.\n"
" */\n"
"#ifndef MAX_LIGHTS\n"
"# define MAX_LIGHTS           35\n"
"#endif\n"
"#ifndef MAX_EX_LIGHTS\n"
"# define MAX_EX_LIGHTS        15\n"
"#endif\n"
"#ifndef NUM_JITTERD_OFFSETS\n"
"# define NUM_JITTERD_OFFSETS 20\n"
"#endif\n"
"#define LIGHT_DIRECTIONAL       0\n"
"#define LIGHT_POINT             1\n"
"#define LIGHT_SPOT              2\n"
"#define AMBIENT_LIGHT_FACTOR    0.0/*0.1*/ //!< Should be in the range [0.0 .. 1.0].\n"
"#define LIGHT_CUTOFF   0.01\n"
"#define MIN_VARIANCE            1.0\n"
"#define EOL      0xFFFFFFFF //!< Id for 'end-of-linked-list'\n"
"#define VPL_SINGULARITY_CLAMP 0.1\n"
"#define VPL_COUNT    100\n"
"#ifdef TILED_SHADING\n"
"# ifndef TILED_LIGHT_GRID_NUM_X\n"
"#  define TILED_LIGHT_GRID_NUM_X 8\n"
"# endif\n"
"# ifndef TILED_LIGHT_GRID_NUM_Y\n"
"#  define TILED_LIGHT_GRID_NUM_Y 8\n"
"# endif\n"
"# ifndef TILED_LIGHT_GRID_WIDTH\n"
"#  define TILED_LIGHT_GRID_WIDTH 32\n"
"# endif\n"
"# ifndef TILED_LIGHT_GRID_HEIGHT\n"
"#  define TILED_LIGHT_GRID_HEIGHT 32\n"
"# endif\n"
"#endif\n"
"struct SLightNode\n"
"{\n"
" uint LightID; //!< SLight index.\n"
" uint Next;  //!< Next SLightNode index. 'EOL' if end of linked list.\n"
"};\n"
"struct SLight\n"
"{\n"
"    float4 PositionAndInvRadius;    //!< Position (xyz), Inverse Radius (w).\n"
"    float3 Color;                   //!< Light color (used for diffuse and specular).\n"
" float Pad0;\n"
"    int Type;                       //!< 0 -> Directional light, 1 -> Point light, 2 -> Spot light.\n"
"    int ShadowIndex;                //!< Shadow map layer index. -1 -> no shadow map.\n"
" int UsedForLightmaps;      //!< Specifies whether this light is used for lightmaps or not.\n"
" int ExID;      //!< Index to the associated 'SLightEx' element.\n"
"};\n"
"struct SLightEx\n"
"{\n"
"    float4x4 ViewProjection;    //!< Spot-/ directional view-projection matrix.\n"
" float4x4 InvViewProjection; //!< Inverse view-projection matrix.\n"
"    float3 Direction;           //!< Spot-/ directional light direction.\n"
" float Pad0;\n"
"    float SpotTheta;   //!< First spot cone angle (in radian).\n"
"    float SpotPhiMinusTheta; //!< Second minus first spot cone angle (in radian).\n"
" float Pad1[2];\n"
"};\n"
"#extension GL_EXT_gpu_shader4 : enable\n"
"#extension GL_EXT_texture_array : enable\n"
"#extension GL_ARB_texture_cube_map_array : enable\n"
"uniform float4x4 WorldViewProjectionMatrix;\n"
"uniform sampler2DArray DirLightShadowMaps;\n"
"uniform samplerCubeArray PointLightShadowMaps;\n"
"uniform sampler2DArray DirLightDiffuseMaps;\n"
"uniform samplerCubeArray PointLightDiffuseMaps;\n"
"uniform int LightShadowIndex;\n"
"uniform float3 LightPosition;\n"
"uniform float4 LightColor;\n"
"uniform float4x4 LightInvViewProjection;\n"
"layout(std140) uniform VPLOffsetBlock\n"
"{\n"
" float4 VPLOffsets[VPL_COUNT];\n"
"};\n"
"layout(location = 0) in float3 Position;\n"
"out float4 VertexColor;\n"
"void main()\n"
"{\n"
" #define INV_SIZE 0.1\n"
" float IndirectDist  = tex2DArray(DirLightShadowMaps, IndirectTexCoord).r;\n"
" float3 IndirectColor = tex2DArray(DirLightDiffuseMaps, IndirectTexCoord).rgb;\n"
" float4 LightRay = float4(IndirectTexCoord.x*2.0 - 1.0, 1.0 - IndirectTexCoord.y*2.0, 1.0, 1.0);\n"
" LightRay = normalize(LightInvViewProjection * LightRay);\n"
" float3 IndirectPoint = LightPosition + LightRay.xyz * float3(IndirectDist);\n"
"    gl_Position = WorldViewProjectionMatrix * float4(Position + IndirectPoint, 1.0);\n"
" VertexColor = LightColor * float4(IndirectColor, 1.0);\n"
"}\n"
