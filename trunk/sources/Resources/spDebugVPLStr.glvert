"/*\n"
" * Debug VPL GLSL vertex shader file\n"
" * \n"
" * This file is part of the \"SoftPixel Engine\" (Copyright (c) 2008 by Lukas Hermanns)\n"
" * See \"SoftPixelEngine.hpp\" for license information.\n"
" */\n"
"#version 330\n"
"/*\n"
" * GLSL shader core file\n"
" * \n"
" * This file is part of the \"SoftPixel Engine\" (Copyright (c) 2008 by Lukas Hermanns)\n"
" * See \"SoftPixelEngine.hpp\" for license information.\n"
" */\n"
"#define PI   3.14159265359\n"
"#define E   2.71828182846\n"
"#define float2  vec2\n"
"#define float3  vec3\n"
"#define float4  vec4\n"
"#define double2  dvec2\n"
"#define double3  dvec3\n"
"#define double4  dvec4\n"
"#define bool2  bvec2\n"
"#define bool3  bvec3\n"
"#define bool4  bvec4\n"
"#define int2  ivec2\n"
"#define int3  ivec3\n"
"#define int4  ivec4\n"
"#define uint2  uvec2\n"
"#define uint3  uvec3\n"
"#define uint4  uvec4\n"
"#define half  float\n"
"#define half2  vec2\n"
"#define half3  vec3\n"
"#define half4  vec4\n"
"#define float2x2 mat2\n"
"#define float3x3 mat3\n"
"#define float4x4 mat4\n"
"#define float2x3 mat2x3\n"
"#define float2x4 mat2x4\n"
"#define float3x2 mat3x2\n"
"#define float3x4 mat3x4\n"
"#define float4x2 mat4x2\n"
"#define float4x3 mat4x3\n"
"#define double2x2 dmat2\n"
"#define double3x3 dmat3\n"
"#define double4x4 dmat4\n"
"#define double2x3 dmat2x3\n"
"#define double2x4 dmat2x4\n"
"#define double3x2 dmat3x2\n"
"#define double3x4 dmat3x4\n"
"#define double4x2 dmat4x2\n"
"#define double4x3 dmat4x3\n"
"#define bool2x2  bmat2\n"
"#define bool3x3  bmat3\n"
"#define bool4x4  bmat4\n"
"#define bool2x3  bmat2x3\n"
"#define bool2x4  bmat2x4\n"
"#define bool3x2  bmat3x2\n"
"#define bool3x4  bmat3x4\n"
"#define bool4x2  bmat4x2\n"
"#define bool4x3  bmat4x3\n"
"#define int2x2  imat2\n"
"#define int3x3  imat3\n"
"#define int4x4  imat4\n"
"#define int2x3  imat2x3\n"
"#define int2x4  imat2x4\n"
"#define int3x2  imat3x2\n"
"#define int3x4  imat3x4\n"
"#define int4x2  imat4x2\n"
"#define int4x3  imat4x3\n"
"#define uint2x2  umat2\n"
"#define uint3x3  umat3\n"
"#define uint4x4  umat4\n"
"#define uint2x3  umat2x3\n"
"#define uint2x4  umat2x4\n"
"#define uint3x2  umat3x2\n"
"#define uint3x4  umat3x4\n"
"#define uint4x2  umat4x2\n"
"#define uint4x3  umat4x3\n"
"#define MUL(m, v)    (m) * (v)\n"
"#define MUL_TRANSPOSED(m, v) transpose(m) * (v)\n"
"#define MUL_NORMAL(n)   (n).xyz = float3x3(Tangent, Binormal, Normal) * (n).xyz\n"
"#define CAST(t, v)    (t(v))\n"
"#define SAMPLER2D(n, i)   uniform sampler2D n\n"
"#define saturate(v)    clamp(v, 0.0, 1.0)\n"
"#define clip(v)     if (v < 0.0) { discard; }\n"
"#define frac(v)     fract(v)\n"
"#define lerp(x, y, s)   mix(x, y, s)\n"
"#define tex2D     texture2D\n"
"#define tex2Dgrad    texture2DGradARB\n"
"#define tex2DArrayLod(s, t)  texture2DArrayLod(s, (t).xyz, (t).w)\n"
"#define tex2DArray(s, t)  texture2DArray(s, t)\n"
"#define tex2DGrad(s, t, dx, dy) texture2DGradARB(s, t, dx, dy)\n"
"#define ddx(v)     dFdx(v)\n"
"#define ddy(v)     dFdy(v)\n"
"#define DeclStructuredBuffer(s, n, r)      \\\n"
" layout(std430, binding = r) readonly buffer Buffer##n \\\n"
" {              \\\n"
"  s n[];            \\\n"
" }\n"
"#define DeclBuffer(t, n, r)         \\\n"
" layout(std430, binding = r) readonly buffer Buffer##n \\\n"
" {              \\\n"
"  t n[];            \\\n"
" }\n"
"#define DeclRWStructuredBuffer(s, n, r)    \\\n"
" layout(std430, binding = r) buffer Buffer##n \\\n"
" {            \\\n"
"  s n[];          \\\n"
" }\n"
"#define DeclRWBuffer(t, n, r)      \\\n"
" layout(std430, binding = r) buffer Buffer##n \\\n"
" {            \\\n"
"  t n[];          \\\n"
" }\n"
"#define DeclConstBuffer(n, r)       layout(std140, binding = r) uniform n\n"
"#define RWTexture3DUInt         layout(r32ui) coherent volatile uimage3D\n"
"#define groupshared          shared\n"
"#define floatBitsToUInt(v)        floatBitsToUint(v)\n"
"#define InterlockedAdd(d, v, o)       o = atomicAdd(d, v)\n"
"#define InterlockedAnd(d, v, o)       o = atomicAnd(d, v)\n"
"#define InterlockedOr(d, v, o)       o = atomicOr(d, v)\n"
"#define InterlockedXor(d, v, o)       o = atomicXor(d, v)\n"
"#define InterlockedMin(d, v, o)       o = atomicMin(d, v)\n"
"#define InterlockedMax(d, v, o)       o = atomicMax(d, v)\n"
"#define InterlockedCompareExchange(d, v, o)    o = atomicCompSwap(d, v)\n"
"#define InterlockedExchange(d, v, o)     o = atomicExchange(d, v)\n"
"#define GroupMemoryBarrier        groupMemoryBarrier\n"
"#define InterlockedImageCompareExchange(i, p, c, v, o) o = imageAtomicCompSwap(i, p, c, v)\n"
"/*\n"
" * Deferred shader header file\n"
" * \n"
" * This file is part of the \"SoftPixel Engine\" (Copyright (c) 2008 by Lukas Hermanns)\n"
" * See \"SoftPixelEngine.hpp\" for license information.\n"
" */\n"
"#ifndef MAX_LIGHTS\n"
"# define MAX_LIGHTS            35\n"
"#endif\n"
"#ifndef MAX_EX_LIGHTS\n"
"# define MAX_EX_LIGHTS         15\n"
"#endif\n"
"#ifndef NUM_JITTERD_OFFSETS\n"
"# define NUM_JITTERD_OFFSETS  20\n"
"#endif\n"
"#define LIGHT_DIRECTIONAL        0\n"
"#define LIGHT_POINT              1\n"
"#define LIGHT_SPOT               2\n"
"#define AMBIENT_LIGHT_FACTOR     0.0/*0.1*/ //!< Should be in the range [0.0 .. 1.0].\n"
"#define LIGHT_CUTOFF    0.01\n"
"#define MIN_VARIANCE             1.0\n"
"#define EOL       0xFFFFFFFF //!< Id for 'end-of-linked-list'\n"
"#define VPL_SINGULARITY_CLAMP  0.1\n"
"#define VPL_COUNT     100\n"
"#define SHININESS_FACTOR   90.0\n"
"#ifdef TILED_SHADING\n"
"# define TILED_LIGHT_GRID_WIDTH 32\n"
"# define TILED_LIGHT_GRID_HEIGHT 32\n"
"#endif\n"
"struct SLightNode\n"
"{\n"
" uint LightID; //!< SLight index.\n"
" uint Next;  //!< Next SLightNode index. 'EOL' if end of linked list.\n"
"};\n"
"#if 0\n"
"struct SLight\n"
"{\n"
" float4 PositionAndRadius;\n"
" float3 Color;\n"
" float SpotTheta;\n"
" float3 Direction;\n"
" float SpotPhiMinusTheta;\n"
" float4x4 ViewProjection;\n"
" float4x4 InvViewProjection;\n"
" int Type;\n"
" int ShadowMapIndex;\n"
" int UsedForLightmaps;\n"
"};\n"
"#endif\n"
"struct SLight\n"
"{\n"
"    float4 PositionAndInvRadius;    //!< Position (xyz), Inverse Radius (w).\n"
"    float3 Color;                   //!< Light color (used for diffuse and specular).\n"
" float Pad0;\n"
"    int Type;                       //!< 0 -> Directional light, 1 -> Point light, 2 -> Spot light.\n"
"    int ShadowIndex;                //!< Shadow map layer index. -1 -> no shadow map.\n"
" int UsedForLightmaps;      //!< Specifies whether this light is used for lightmaps or not.\n"
" int ExID;      //!< Index to the associated 'SLightEx' element.\n"
"};\n"
"struct SLightEx\n"
"{\n"
"    float4x4 ViewProjection;    //!< Spot-/ directional view-projection matrix.\n"
" float4x4 InvViewProjection; //!< Inverse view-projection matrix.\n"
"    float3 Direction;           //!< Spot-/ directional light direction.\n"
" float Pad0;\n"
"    float SpotTheta;   //!< First spot cone angle (in radian).\n"
"    float SpotPhiMinusTheta; //!< Second minus first spot cone angle (in radian).\n"
" float Pad1[2];\n"
"};\n"
"#extension GL_EXT_gpu_shader4 : enable\n"
"#extension GL_EXT_texture_array : enable\n"
"#extension GL_ARB_texture_cube_map_array : enable\n"
"uniform float4x4 WorldViewProjectionMatrix;\n"
"uniform sampler2DArray DirLightShadowMaps;\n"
"uniform samplerCubeArray PointLightShadowMaps;\n"
"uniform sampler2DArray DirLightDiffuseMaps;\n"
"uniform samplerCubeArray PointLightDiffuseMaps;\n"
"uniform int LightShadowIndex;\n"
"uniform float3 LightPosition;\n"
"uniform float4 LightColor;\n"
"uniform float4x4 LightInvViewProjection;\n"
"layout(std140) uniform VPLOffsetBlock\n"
"{\n"
" float4 VPLOffsets[VPL_COUNT];\n"
"};\n"
"layout(location = 0) in float3 Position;\n"
"out float4 VertexColor;\n"
"void main()\n"
"{\n"
" #define INV_SIZE 0.1\n"
" #if 0//!!!\n"
" float3 IndirectTexCoord = float3(\n"
"  float(gl_InstanceID % 11) * INV_SIZE,\n"
"  float(gl_InstanceID / 11) * INV_SIZE,\n"
"  float(LightShadowIndex)\n"
" );\n"
" #elif 1//!!!\n"
" float3 IndirectTexCoord = float3(\n"
"  float(1 + gl_InstanceID % 5) / 6.0,\n"
"  float(gl_InstanceID / 5) * 0.05,\n"
"  float(LightShadowIndex)\n"
" );\n"
" float2 v = float2(\n"
"  IndirectTexCoord.x * IndirectTexCoord.x * cos(2.0*PI*IndirectTexCoord.y),\n"
"  IndirectTexCoord.x * IndirectTexCoord.x * sin(2.0*PI*IndirectTexCoord.y)\n"
" );\n"
" IndirectTexCoord.xy = v*0.5 + 0.5;\n"
" #else\n"
" float3 IndirectTexCoord = float3(VPLOffsets[gl_InstanceID].xy, float(LightShadowIndex));\n"
" #endif\n"
" float IndirectDist  = tex2DArray(DirLightShadowMaps, IndirectTexCoord).r;\n"
" float3 IndirectColor = tex2DArray(DirLightDiffuseMaps, IndirectTexCoord).rgb;\n"
" float4 LightRay = float4(IndirectTexCoord.x*2.0 - 1.0, 1.0 - IndirectTexCoord.y*2.0, 1.0, 1.0);\n"
" LightRay = normalize(LightInvViewProjection * LightRay);\n"
" float3 IndirectPoint = LightPosition + LightRay.xyz * float3(IndirectDist);\n"
"    gl_Position = WorldViewProjectionMatrix * float4(Position + IndirectPoint, 1.0);\n"
" VertexColor = LightColor * float4(IndirectColor, 1.0);\n"
"}\n"
