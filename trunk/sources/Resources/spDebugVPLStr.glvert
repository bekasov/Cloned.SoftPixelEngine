"/*\n"
" * Debug VPL GLSL vertex shader file\n"
" * \n"
" * This file is part of the \"SoftPixel Engine\" (Copyright (c) 2008 by Lukas Hermanns)\n"
" * See \"SoftPixelEngine.hpp\" for license information.\n"
" */\n"
"\n"
"#version 330\n"
"\n"
"#extension GL_EXT_gpu_shader4 : enable\n"
"#extension GL_EXT_texture_array : enable\n"
"#extension GL_ARB_texture_cube_map_array : enable\n"
"\n"
"/* === Uniforms === */\n"
"\n"
"uniform float4x4 WorldViewProjectionMatrix;\n"
"\n"
"uniform sampler2DArray DirLightShadowMaps;\n"
"uniform samplerCubeArray PointLightShadowMaps;\n"
"\n"
"uniform sampler2DArray DirLightDiffuseMaps;\n"
"uniform samplerCubeArray PointLightDiffuseMaps;\n"
"\n"
"//uniform sampler2DArray DirLightNormalMaps;\n"
"//uniform samplerCubeArray PointLightNormalMaps;\n"
"\n"
"uniform int LightShadowIndex;\n"
"uniform float3 LightPosition;\n"
"uniform float4 LightColor;\n"
"uniform float4x4 LightInvViewProjection;\n"
"\n"
"layout(std140) uniform VPLOffsetBlock\n"
"{\n"
"    float4 VPLOffsets[100];\n"
"};\n"
"\n"
"/* === Varyings === */\n"
"\n"
"layout(location = 0) in float3 Position;\n"
"\n"
"out float4 VertexColor;\n"
"\n"
"/* === Functions === */\n"
"\n"
"void main()\n"
"{\n"
"    /* Generate virtual point lights */\n"
"    #define INV_SIZE 0.1\n"
"    \n"
"    #if 0\n"
"    \n"
"    float3 IndirectTexCoord = float3(\n"
"        float(gl_InstanceID % 11) * INV_SIZE,\n"
"        float(gl_InstanceID / 11) * INV_SIZE,\n"
"        float(LightShadowIndex)\n"
"    );\n"
"    \n"
"    #elif 0\n"
"    \n"
"    float3 IndirectTexCoord = float3(\n"
"        float(1 + gl_InstanceID % 5) / 6.0,\n"
"        float(gl_InstanceID / 5) * 0.05,\n"
"        float(LightShadowIndex)\n"
"    );\n"
"    \n"
"    float2 v = float2(\n"
"        IndirectTexCoord.x * IndirectTexCoord.x * cos(2.0*PI*IndirectTexCoord.y),\n"
"        IndirectTexCoord.x * IndirectTexCoord.x * sin(2.0*PI*IndirectTexCoord.y)\n"
"    );\n"
"    \n"
"    IndirectTexCoord.xy = v*0.5 + 0.5;\n"
"    \n"
"    #else\n"
"    \n"
"    float3 IndirectTexCoord = float3(VPLOffsets[gl_InstanceID].xy, float(LightShadowIndex));\n"
"    \n"
"    #endif\n"
"    \n"
"    /* Get distance and color from indirect light */\n"
"    float IndirectDist        = tex2DArray(DirLightShadowMaps, IndirectTexCoord).r;\n"
"    float3 IndirectColor    = tex2DArray(DirLightDiffuseMaps, IndirectTexCoord).rgb;\n"
"    \n"
"    /* Get the indirect light's position */\n"
"    float4 LightRay = float4(IndirectTexCoord.x*2.0 - 1.0, 1.0 - IndirectTexCoord.y*2.0, 1.0, 1.0);\n"
"    LightRay = normalize(LightInvViewProjection * LightRay);\n"
"    float3 IndirectPoint = LightPosition + LightRay.xyz * float3(IndirectDist);\n"
"    \n"
"    /* Vertex processing */\n"
"    gl_Position    = WorldViewProjectionMatrix * float4(Position + IndirectPoint, 1.0);\n"
"    VertexColor = LightColor * float4(IndirectColor, 1.0);\n"
"}\n"
"\n"
"\n"
