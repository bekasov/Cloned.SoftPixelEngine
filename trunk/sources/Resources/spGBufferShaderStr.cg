"/*\n"
" * GBuffer Cg shader file\n"
" * \n"
" * This file is part of the \"SoftPixel Engine\" (Copyright (c) 2008 by Lukas Hermanns)\n"
" * See \"SoftPixelEngine.hpp\" for license information.\n"
" */\n"
"\n"
"/*\n"
"\n"
"Compilation options:\n"
"\n"
"USE_TEXTURE_MATRIX  -> Enables texture matrix transformations for texture coordinates.\n"
"NORMAL_MAPPING      -> Enables normal mapping.\n"
"PARALLAX_MAPPING    -> Enables parallax-occlusion mapping (Requires NORMAL_MAPPING to be enabled).\n"
"NORMALMAP_XYZ_H        -> Normal map contains vector data (xyz in RGB) and height-field data (h in Alpha-Channel). When this is defined, no height-map is used for parallax-mapping.\n"
"TESSELLATION        -> Enables height-field tessellation.\n"
"HAS_SPECULAR_MAP    -> Specifies that a specular is used.\n"
"\n"
"*/\n"
"\n"
"/*\n"
" * ======= Vertex shader: =======\n"
" */\n"
"\n"
"/* === Structures === */\n"
"\n"
"struct SVertexInput\n"
"{\n"
"    float3 Position : POSITION;\n"
"    float3 Normal   : NORMAL;\n"
"    float2 TexCoord : TEXCOORD0;\n"
"    #ifdef NORMAL_MAPPING\n"
"    float3 Tangent  : TEXCOORD1;\n"
"    float3 Binormal : TEXCOORD2;\n"
"    #endif\n"
"};\n"
"\n"
"struct SVertexOutput\n"
"{\n"
"    float4 Position                 : POSITION;\n"
"    float2 TexCoord                 : TEXCOORD0;\n"
"    float4 WorldPos                 : TEXCOORD1;\n"
"    float3 Normal                   : TEXCOORD2;\n"
"    #ifdef NORMAL_MAPPING\n"
"    float3 Tangent                  : TEXCOORD3;\n"
"    float3 Binormal                 : TEXCOORD4;\n"
"    #   ifdef PARALLAX_MAPPING\n"
"    float4 ViewVertexDirAndDepth    : TEXCOORD5;\n"
"    #   endif\n"
"    #endif\n"
"};\n"
"\n"
"\n"
"/* === Uniforms === */\n"
"\n"
"uniform float4x4 WorldViewProjectionMatrix;\n"
"uniform float4x4 WorldMatrix;\n"
"\n"
"#ifdef USE_TEXTURE_MATRIX\n"
"uniform float4x4 TextureMatrix;\n"
"#endif\n"
"\n"
"uniform float3 ViewPosition;    //!< Global camera position.\n"
"\n"
"\n"
"/* === Functions === */\n"
"\n"
"SVertexOutput VertexMain(SVertexInput In)\n"
"{\n"
"    SVertexOutput Out = (SVertexOutput)0;\n"
"    \n"
"    /* Process vertex transformation for position and normal */\n"
"    Out.Position    = mul(WorldViewProjectionMatrix, float4(In.Position, 1.0));\n"
"    Out.WorldPos    = mul(WorldMatrix, float4(In.Position, 1.0));\n"
"    Out.Normal      = mul((float3x3)WorldMatrix, In.Normal);\n"
"\n"
"    #ifdef NORMAL_MAPPING\n"
"    \n"
"    /* Process transformation for tangent space */\n"
"    Out.Tangent     = mul((float3x3)WorldMatrix, In.Tangent);\n"
"    Out.Binormal    = mul((float3x3)WorldMatrix, In.Binormal);\n"
"\n"
"    #   ifdef PARALLAX_MAPPING\n"
"    float3x3 NormalMatrix = float3x3(\n"
"        normalize(Out.Tangent),\n"
"        normalize(Out.Binormal),\n"
"        normalize(Out.Normal)\n"
"    );\n"
"\n"
"    Out.ViewVertexDirAndDepth.xyz   = ViewPosition - Out.WorldPos.xyz;\n"
"    Out.ViewVertexDirAndDepth.xyz   = mul(NormalMatrix, Out.ViewVertexDirAndDepth.xyz);\n"
"    Out.ViewVertexDirAndDepth.y     = -Out.ViewVertexDirAndDepth.y;\n"
"\n"
"    Out.ViewVertexDirAndDepth.w     = Out.Position.z;\n"
"    #   endif\n"
"\n"
"    #endif\n"
"\n"
"    #ifdef USE_TEXTURE_MATRIX\n"
"    Out.TexCoord = (float2)mul(TextureMatrix, float4(In.TexCoord, 0.0, 1.0));\n"
"    #else\n"
"    Out.TexCoord = In.TexCoord;\n"
"    #endif\n"
"    \n"
"    return Out;\n"
"}\n"
"\n"
"\n"
"#ifdef TESSELLATION\n"
"\n"
"/*\n"
" * ======= Hull Shader: =======\n"
" */\n"
"\n"
"/* === Structures === */\n"
"\n"
"struct SHullInput\n"
"{\n"
"    int Id                          : CONTROLPOINT_ID;\n"
"    AttribArray<float4> Position    : POSITION;\n"
"};\n"
"\n"
"struct SHullOutput\n"
"{\n"
"    float4 Position     : POSITION;\n"
"    float EdgeTess[3]   : EDGETESS;\n"
"    float InnerTess     : INNERTESS;\n"
"};\n"
"\n"
"\n"
"/* === Functions === */\n"
"\n"
"gp5tcp PATCH_3\n"
"SHullOutput HullMain(SHullInput In)\n"
"{\n"
"    SHullOutput Out = (SHullOutput)0;\n"
"\n"
"\n"
"    return Out;\n"
"}\n"
"\n"
"\n"
"/*\n"
" * ======= Domain Shader: =======\n"
" */\n"
"\n"
"/* === Structures === */\n"
"\n"
"struct SDomainInput\n"
"{\n"
"    float2 ChangeOver               : UV;\n"
"    AttribArray<float4> Position    : POSITION;\n"
"};\n"
"\n"
"struct SDomainOutput\n"
"{\n"
"    float4 Position : POSITION;\n"
"};\n"
"\n"
"\n"
"/* === Functions === */\n"
"\n"
"gp5tep TRIANGLES PATCH_3\n"
"SDomainOutput DomainMain(SDomainInput In)\n"
"{\n"
"    SDomainOutput Out = (SDomainOutput)0;\n"
"\n"
"\n"
"    return Out;\n"
"}\n"
"\n"
"#endif\n"
"\n"
"\n"
"/*\n"
" * ======= Pixel shader: =======\n"
" */\n"
"\n"
"/* === Structures === */\n"
"\n"
"struct SPixelInput\n"
"{\n"
"    float2 TexCoord                 : TEXCOORD0;\n"
"    float4 WorldPos                 : TEXCOORD1;\n"
"    float3 Normal                   : TEXCOORD2;\n"
"    #ifdef NORMAL_MAPPING\n"
"    float3 Tangent                  : TEXCOORD3;\n"
"    float3 Binormal                 : TEXCOORD4;\n"
"    #   ifdef PARALLAX_MAPPING\n"
"    float4 ViewVertexDirAndDepth    : TEXCOORD5; //!< View/vertex direction (xyz) and view depth (w).\n"
"    #   endif\n"
"    #endif\n"
"};\n"
"\n"
"struct SPixelOutput\n"
"{\n"
"    float4 DiffuseAndSpecular   : COLOR0;\n"
"    float4 NormalAndDepth       : COLOR1;\n"
"};\n"
"\n"
"\n"
"/* === Uniforms === */\n"
"\n"
"uniform sampler2D DiffuseMap : TEXUNIT0;\n"
"\n"
"#ifdef HAS_SPECULAR_MAP\n"
"uniform sampler2D SpecularMap : TEXUNIT1;\n"
"#endif\n"
"\n"
"#ifdef NORMAL_MAPPING\n"
"\n"
"// Contains only height-field information (in the alpha channel) when PARALLAX_MAPPING is enabled\n"
"#   ifdef HAS_SPECULAR_MAP\n"
"uniform sampler2D NormalMap : TEXUNIT2;\n"
"#       if defined(PARALLAX_MAPPING) && !defined(NORMALMAP_XYZ_H)\n"
"uniform sampler2D HeightMap : TEXUNIT3;\n"
"#       endif\n"
"#   else\n"
"uniform sampler2D NormalMap : TEXUNIT1;\n"
"#       if defined(PARALLAX_MAPPING) && !defined(NORMALMAP_XYZ_H)\n"
"uniform sampler2D HeightMap : TEXUNIT2;\n"
"#       endif\n"
"#   endif\n"
"\n"
"#   ifdef PARALLAX_MAPPING\n"
"\n"
"uniform bool EnablePOM;\n"
"uniform int MinSamplesPOM;\n"
"uniform int MaxSamplesPOM;\n"
"uniform float HeightMapScale;\n"
"uniform float ParallaxViewRange;\n"
"\n"
"#   endif\n"
"\n"
"#endif\n"
"\n"
"uniform float SpecularFactor;\n"
"\n"
"\n"
"/* === Functions === */\n"
"\n"
"SPixelOutput PixelMain(SPixelInput In)\n"
"{\n"
"    SPixelOutput Out = (SPixelOutput)0;\n"
"    \n"
"    #ifndef NORMAL_MAPPING\n"
"\n"
"    /* Sample diffuse color */\n"
"    Out.DiffuseAndSpecular = tex2D(DiffuseMap, In.TexCoord);\n"
"\n"
"    #   ifdef HAS_SPECULAR_MAP\n"
"    /* Sample specular color */\n"
"    Out.DiffuseAndSpecular.a = tex2D(SpecularMap, In.TexCoord).r * SpecularFactor;\n"
"    #   endif\n"
"\n"
"    Out.NormalAndDepth.xyz = In.Normal;\n"
"\n"
"    #else\n"
"\n"
"    /* Compute normal in tangent-space */\n"
"    float3x3 NormalMatrix = float3x3(\n"
"        normalize(In.Tangent),\n"
"        normalize(In.Binormal),\n"
"        normalize(In.Normal)\n"
"    );\n"
"\n"
"    #   ifdef PARALLAX_MAPPING\n"
"    if (!EnablePOM)\n"
"    {\n"
"    #   endif\n"
"        /* Sample diffuse color */\n"
"        Out.DiffuseAndSpecular = tex2D(DiffuseMap, In.TexCoord);\n"
"        \n"
"        /* Perform alpha-test clipping */\n"
"        clip(Out.DiffuseAndSpecular.a - 0.5);\n"
"        \n"
"        /* Sample normal color */\n"
"        Out.NormalAndDepth.xyz = tex2D(NormalMap, In.TexCoord).rgb;\n"
"        \n"
"        #ifdef HAS_SPECULAR_MAP\n"
"        /* Sample specular color */\n"
"        Out.DiffuseAndSpecular.a = tex2D(SpecularMap, In.TexCoord).r * SpecularFactor;\n"
"        #endif\n"
"    #   ifdef PARALLAX_MAPPING\n"
"    }\n"
"    else\n"
"    {\n"
"        /* Compute parallax-occlusion displacement */\n"
"        float ParallaxLimit = (length(In.ViewVertexDirAndDepth.xy) / In.ViewVertexDirAndDepth.z) * HeightMapScale;\n"
"        \n"
"        float2 Offset = normalize(-In.ViewVertexDirAndDepth.xy) * ParallaxLimit;\n"
"        \n"
"        float Interpolation = clamp(ParallaxViewRange / In.ViewVertexDirAndDepth.w, 0.0, 1.0);\n"
"        int NumSamples      = int(mix(float(MinSamplesPOM), float(MaxSamplesPOM), Interpolation));\n"
"        \n"
"        float StepSize = 1.0 / float(NumSamples);\n"
"        \n"
"        float2 dx = ddx(In.TexCoord);\n"
"        float2 dy = ddy(In.TexCoord);\n"
"        \n"
"        float2 OffsetStep   = Offset * StepSize;\n"
"        \n"
"        float2 CurOffset    = (float)0;\n"
"        float2 PrevOffset   = (float)0;\n"
"        float CurSample     = 0.0;\n"
"        float PrevSample    = 0.0;\n"
"        \n"
"        float StepHeight    = 1.0;\n"
"        int SampleIndex     = 0;\n"
"        \n"
"        while (SampleIndex < NumSamples)\n"
"        {\n"
"            #ifdef NORMALMAP_XYZ_H\n"
"            CurSample = tex2D(NormalMap, In.TexCoord + CurOffset, dx, dy).a;\n"
"            #else\n"
"            CurSample = tex2D(HeightMap, In.TexCoord + CurOffset, dx, dy).r;\n"
"            #endif\n"
"            \n"
"            if (CurSample > StepHeight)\n"
"            {\n"
"                float Ua = (PrevSample - (StepHeight + StepSize)) / (StepSize + (CurSample - PrevSample));\n"
"                CurOffset = PrevOffset + OffsetStep * Ua;\n"
"                break;\n"
"            }\n"
"            else\n"
"            {\n"
"                ++SampleIndex;\n"
"                StepHeight -= StepSize;\n"
"                PrevOffset = CurOffset;\n"
"                CurOffset += OffsetStep;\n"
"                PrevSample = CurSample;\n"
"            }\n"
"        }\n"
"        \n"
"        /* Sample diffuse color */\n"
"        Out.DiffuseAndSpecular = tex2D(DiffuseMap, In.TexCoord + CurOffset, dx, dy);\n"
"        \n"
"        /* Sample normal color */\n"
"        Out.NormalAndDepth.xyz = tex2D(NormalMap, In.TexCoord + CurOffset, dx, dy).rgb;\n"
"        \n"
"        /* Perform alpha-test clipping */\n"
"        clip(Out.DiffuseAndSpecular.a - 0.5);\n"
"        \n"
"        #ifdef HAS_SPECULAR_MAP\n"
"        /* Sample specular color */\n"
"        Out.DiffuseAndSpecular.a = tex2D(SpecularMap, In.TexCoord + CurOffset, dx, dy).r * SpecularFactor;\n"
"        #endif\n"
"    }\n"
"\n"
"    #   endif // /PARALLAX_MAPPING\n"
"\n"
"    /* Transform final normal vector into tangent-space */\n"
"    Out.NormalAndDepth.xyz = Out.NormalAndDepth.xyz * float3(2.0) - float3(1.0);\n"
"    Out.NormalAndDepth.xyz = mul(Out.NormalAndDepth.xyz, NormalMatrix);\n"
"\n"
"    #endif // /NORMAL_MAPPING\n"
"\n"
"    #ifndef HAS_SPECULAR_MAP\n"
"    Out.DiffuseAndSpecular.a = SpecularFactor;\n"
"    #endif\n"
"\n"
"    /* Compute depth distance between view position and pixel position */\n"
"    Out.NormalAndDepth.a = distance(ViewPosition, In.WorldPos);\n"
"\n"
"    return Out;\n"
"}\n"
