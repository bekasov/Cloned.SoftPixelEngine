"/*\n"
" * Deferred GLSL vertex shader file\n"
" * \n"
" * This file is part of the \"SoftPixel Engine\" (Copyright (c) 2008 by Lukas Hermanns)\n"
" * See \"SoftPixelEngine.hpp\" for license information.\n"
" */\n"
"#version 130\n"
"/*\n"
" * GLSL shader core file\n"
" * \n"
" * This file is part of the \"SoftPixel Engine\" (Copyright (c) 2008 by Lukas Hermanns)\n"
" * See \"SoftPixelEngine.hpp\" for license information.\n"
" */\n"
"#define SP_ONLY_FLOAT_MATRICES\n"
"#define SP_GLSL 1\n"
"#define PI   3.14159265359\n"
"#define E   2.71828182846\n"
"#define float2  vec2\n"
"#define float3  vec3\n"
"#define float4  vec4\n"
"#define double2  dvec2\n"
"#define double3  dvec3\n"
"#define double4  dvec4\n"
"#define bool2  bvec2\n"
"#define bool3  bvec3\n"
"#define bool4  bvec4\n"
"#define int2  ivec2\n"
"#define int3  ivec3\n"
"#define int4  ivec4\n"
"#define uint2  uvec2\n"
"#define uint3  uvec3\n"
"#define uint4  uvec4\n"
"#define half  float\n"
"#define half2  vec2\n"
"#define half3  vec3\n"
"#define half4  vec4\n"
"#define float2x2 mat2\n"
"#define float3x3 mat3\n"
"#define float4x4 mat4\n"
"#define float2x3 mat2x3\n"
"#define float2x4 mat2x4\n"
"#define float3x2 mat3x2\n"
"#define float3x4 mat3x4\n"
"#define float4x2 mat4x2\n"
"#define float4x3 mat4x3\n"
"#define double2x2 dmat2\n"
"#define double3x3 dmat3\n"
"#define double4x4 dmat4\n"
"#define double2x3 dmat2x3\n"
"#define double2x4 dmat2x4\n"
"#define double3x2 dmat3x2\n"
"#define double3x4 dmat3x4\n"
"#define double4x2 dmat4x2\n"
"#define double4x3 dmat4x3\n"
"#define MUL(m, v)    (m) * (v)\n"
"#define MUL_TRANSPOSED(m, v) transpose(m) * (v)\n"
"#define MUL_NORMAL(n)   (n).xyz = float3x3(Tangent, Binormal, Normal) * (n).xyz\n"
"#define CAST(t, v)    (t(v))\n"
"#define SAMPLER2D(n, i)   uniform sampler2D n\n"
"#define saturate(v)    clamp(v, 0.0, 1.0)\n"
"#define clip(v)     if (v < 0.0) { discard; }\n"
"#define frac(v)     fract(v)\n"
"#define lerp(x, y, s)   mix(x, y, s)\n"
"#define tex2D     texture2D\n"
"#define tex2Dgrad    texture2DGradARB\n"
"#define tex2DArrayLod(s, t)  texture2DArrayLod(s, (t).xyz, (t).w)\n"
"#define tex2DArray(s, t)  texture2DArray(s, t)\n"
"#define tex2DGrad(s, t, dx, dy) texture2DGradARB(s, t, dx, dy)\n"
"#define ddx(v)     dFdx(v)\n"
"#define ddy(v)     dFdy(v)\n"
"#define DeclStructuredBuffer(s, n, r)      \\\n"
" layout(std430, binding = r) readonly buffer Buffer##n \\\n"
" {              \\\n"
"  s n[];            \\\n"
" }\n"
"#define DeclBuffer(t, n, r)         \\\n"
" layout(std430, binding = r) readonly buffer Buffer##n \\\n"
" {              \\\n"
"  t n[];            \\\n"
" }\n"
"#define DeclRWStructuredBuffer(s, n, r)    \\\n"
" layout(std430, binding = r) buffer Buffer##n \\\n"
" {            \\\n"
"  s n[];          \\\n"
" }\n"
"#define DeclRWBuffer(t, n, r)      \\\n"
" layout(std430, binding = r) buffer Buffer##n \\\n"
" {            \\\n"
"  t n[];          \\\n"
" }\n"
"#define DeclConstBuffer(n, r)       layout(std140, binding = r) uniform n\n"
"#define RWTexture3DUInt         layout(r32ui) coherent volatile uimage3D\n"
"#define groupshared          shared\n"
"#define floatBitsToUInt(v)        floatBitsToUint(v)\n"
"#define InterlockedAdd(d, v, o)       o = atomicAdd(d, v)\n"
"#define InterlockedAnd(d, v, o)       o = atomicAnd(d, v)\n"
"#define InterlockedOr(d, v, o)       o = atomicOr(d, v)\n"
"#define InterlockedXor(d, v, o)       o = atomicXor(d, v)\n"
"#define InterlockedMin(d, v, o)       o = atomicMin(d, v)\n"
"#define InterlockedMax(d, v, o)       o = atomicMax(d, v)\n"
"#define InterlockedCompareExchange(d, v, o)    o = atomicCompSwap(d, v)\n"
"#define InterlockedExchange(d, v, o)     o = atomicExchange(d, v)\n"
"#define GroupMemoryBarrier        groupMemoryBarrier\n"
"#define InterlockedImageCompareExchange(i, p, c, v, o) o = imageAtomicCompSwap(i, p, c, v)\n"
"#define __DEFINE_MUL_FUNC__(m, v)  \\\n"
" v mul(m mat, v vec)     \\\n"
" {         \\\n"
"  return mat * vec;    \\\n"
" }         \\\n"
" v mul(v vec, m mat)     \\\n"
" {         \\\n"
"  return transpose(mat) * vec; \\\n"
" }         \\\n"
" m mul(m a, m b)      \\\n"
" {         \\\n"
"  return a * b;     \\\n"
" }\n"
"__DEFINE_MUL_FUNC__(float2x2, float2)\n"
"__DEFINE_MUL_FUNC__(float3x3, float3)\n"
"__DEFINE_MUL_FUNC__(float4x4, float4)\n"
"#undef __DEFINE_MUL_FUNC__\n"
"uniform float4x4 ProjectionMatrix; //!< 2D drawing projection matrix\n"
"uniform float4x4 InvViewProjection; //!< Inverse view-projection matrix.\n"
"out float2 TexCoord;\n"
"out float4 ViewRay;\n"
"void Frustum(inout float4 v)\n"
"{\n"
"    v.x = (v.x - 0.5) * 2.0;\n"
"    v.y = (v.y - 0.5) * 2.0;\n"
"}\n"
"void main()\n"
"{\n"
"    /* Process vertex transformation for position and normal */\n"
"    gl_Position = ProjectionMatrix * gl_Vertex;\n"
"    TexCoord = gl_MultiTexCoord0.xy;\n"
"    ViewRay = float4(TexCoord.x, 1.0 - TexCoord.y, 1.0, 1.0);\n"
"    Frustum(ViewRay);\n"
" ViewRay = InvViewProjection * ViewRay;\n"
"}\n"
